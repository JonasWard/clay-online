{"version":3,"sources":["geometry/shaders-materials.js","geometry/importing-jsts.js","geometry/clayBrick/clay-point.js","geometry/three/three-poly-line.js","geometry/clayBrick/clay-patterns.js","geometry/clayBrick/clay-pattern-curve.js","geometry/jsts2Three/jsts-to-three.js","geometry/jsts2Three/three-to-jsts.js","three-setup/renderers.js","three-setup/set-up.js","three-setup/render-loops.js","geometry/three/brick-to-scene.js","three-setup/cameras.js","three-setup/orbit-controls.js","geometry/clayBrick/clay-simple-base.js","three-setup/gui-setup.js","Viewer.js","App.js","reportWebVitals.js","index.js"],"names":["triangulationFromPolygon","polygon","builder","DelaunayTriangulationBuilder","setSites","setTolerance","getTriangles","GeometryFactory","edgesFromTriangulation","triangulation","vertexDict","vPairs","pureVertices","boundary","_geometries","coords","getGeometryN","getCoordinates","length","cMap","idx","coor","coordinate","JSON","stringify","x","y","z","dictCount","Object","keys","Vector3","a","b","v0","Math","min","v1","max","idxVertex","v","lines","localLineCurve","LineCurve","push","bufferFromTriangulation","bufferGeo","BufferGeometry","coordinatesList","vertices","Float32Array","setAttribute","BufferAttribute","computeVertexNormals","createBuffer","geom","radius","segments","BufferOp","bufferOp","geometriesDifference","geosA","geosB","difference","geometriesIntersection","intersection","geometryUnion","geos","collection","createGeometryCollection","union","geometriesUnion","UnaryUnionOp","multiplePoints","strings","reader","WKTReader","aString","read","readWKString","bufferedGeos","geo","displayPointTest","plg","buffer","edges","triangulatePolyline","ClayPoint","origin","direction","this","position","copy","value","addVectors","addScaledVector","Coordinate","Polyline","Curve","points","closed","init","dirs","getDirs","arcLengthDivisions","getPointCount","dirList","i","vDir","subVectors","lengths","getLengths","cacheArcLengths","needsUpdate","previous","u","optionalTarget","getTangent","t","vT","locT","roundT","isNaN","normalize","set","normal","tangents","normals","binormals","vec","mat","Matrix4","getTangentAt","Number","MAX_VALUE","tx","abs","ty","tz","crossVectors","clone","EPSILON","theta","acos","clamp","dot","applyMatrix4","makeRotationAxis","t0","getPoint","_tConstraining","height","point","periods","amplitude","step","PI","phase","sin","pt","sinWaveUVPattern","uv","parameters","phaseDelta","period","offset","unitRadiusForDot","localU","localV","baseU","uSpacing","baseV","vSpacing","positionShift","dotForUV","radiusScaleV","localDistance","sqrt","edgeUVConstraining","easingParameters","endLength","startLength","startMaxLength","endMaxLength","easingDelta","DEFAULT_SIN_WAVE_UV_PARAMETERS","default","DEFAULT_UV_DOT_PARAMETERS","PATTERN_LIST","patternParameters","patternFunction","dotPyramidUVPattern","dotEllipsoidUVPattern","locRadius","dotInverseUVPattern","cylinderUVFunction","radiusA","radiusB","localR","round","dotCylinderForUV","rD","ClayPatternCurve","clayPoints","coordinates","toCoordinate","createPolygon","positions","toVector3","edgeValue","uvValue","createLinearRing","vectorFromCoordinate","locZ","linearRingToPolyline","linearRing","vectors","pop","polygonToPolylines","polylines","constructor","name","pg","pl","lrs","linearRings","getExteriorRing","getNumInteriorRing","getInteriorRingN","getLinearRings","lr","polylineToPolygon","polyline","vector3","coordinatesFromPolyline","resize","mount","renderer","camera","current","clientWidth","clientHeight","aspect","updateProjectionMatrix","setSize","scene","start","frameId","requestAnimationFrame","animate","clear","render","setUp","Scene","light","directionalLight","DirectionalLight","castShadow","shadow","near","far","bias","mapSize","width","addLighting","add","addBrick","WebGL1Renderer","antialias","alpha","setPixelRatio","window","devicePixelRatio","shadowMap","enabled","type","PCFShadowMap","getPerspectiveRenderer","appendChild","domElement","PerspectiveCamera","getPerspectiveCamera","orbitControls","OrbitControls","enableRotate","enableKeys","target","update","getOrbitControls","cleanUp","cancelAnimationFrame","stop","removeChild","overwrites","geometryArray","OVERWRITE_SETTINGS","productionWidth","baseWidth","baseLength","lengthBufferMultiplier","pinSpacing","diamondWidth","diamondHeight","diamondCount","pinDiameter0","pinDiameter1","pinDelta","pinDivisions","precision","bodyHeight","totalHeight","startHeight","layerHeight","easingStart","easingEnd","pattern","patternClone","patternSettingsClone","key","updateEasingSettings","locTotalLength","obj","remove","geometry","dispose","material","console","log","clearScene","pls","constructBrick","loader","TextureLoader","pipeRadius","load","texture","brickShader","MeshLambertMaterial","map","tubeGeo","TubeGeometry","locMesh","Mesh","receiveShadow","undefined","err","error","applyBrickShader","pinRadiusAtHeight","p","pinDiameterDelta","arcClayPt","startPhase","angleDelta","basePoint","vVal","baseAngle","angle","x0","cos","y0","clayPoint","Vector2","arcDivisions","goalLength","arcAngle","count","ceil","lineDivisions","distanceTo","delta","deltaLength","outerProfile","p0","p1","p2","p3","clayPolyline","simpleLineDivison","divisions","withEnds","vs","end","simpleArcDivision","division","diamondPolyline","bPoint","rectangle","innerProfileGeom","diamondVs","diamondV","diamond","diamondRect","pinDiameter","polygons","aSlice","outerClayCurve","applyPattern","outerGeom","toPolygon","bufferedOuterGeom","recL","leftRec","leftRecPg","unionOuterGeom","innerGeom","path","aPinOnlySlice","arcA","arcB","cadFlip","localH","moveToHeight","overwriteClone","addAllOverwrites","guiElement","overwriteElement","onChange","addPatternOverwrites","overwritePatternElement","patternName","Viewer","useRef","rendererRef","cameraRef","useEffect","gui","GUI","autoPlace","localPatternGUI","addFolder","patternParameter","defaultParameters","overwriteName","hasOwnProperty","createGUI","bounds","onResize","measureRef","className","ref","tabIndex","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"0PAAO,I,oDCSP,SAASA,EAAyBC,GAC9B,IAAMC,EAAU,IAAIC,IASpB,OAPAD,EAAQE,SAASH,GACjBC,EAAQG,aAAa,KAEDH,EAAQI,aAAa,IAAIC,KAYjD,SAASC,EAAuBC,GAC5B,IAAIC,EAAa,GACbC,EAAS,GACTC,EAAe,GAEnB,IAAK,IAAMC,KAAYJ,EAAcK,YAAa,CAC9C,IACMC,EADMN,EAAcO,aAAaH,GACpBI,iBAEnB,GAAsB,IAAlBF,EAAOG,OAAc,CACrB,IAAIC,EAAO,CAAC,EAAG,EAAG,GAClB,IAAK,IAAMC,IAAO,CAAC,EAAE,EAAE,GAAI,CACvB,IAAMC,EAAON,EAAOK,GAEhBE,EAAaC,KAAKC,UAAU,CAACC,EAAGJ,EAAKI,EAAGC,EAAGL,EAAKK,EAAGC,EAAG,KAEpDC,EAAYC,OAAOC,KAAKpB,GAAYQ,OAEpCI,KAAcZ,EAOhBS,EAAKC,GAAOV,EAAWY,IAJvBZ,EAAWY,GAAcM,EACzBhB,EAAaU,GAAc,IAAIS,IAAQV,EAAKI,EAAGJ,EAAKK,EAAG,IACvDP,EAAKC,GAAOQ,GAQpB,IAAK,IAAMR,IAAO,CAAC,EAAE,EAAE,GAAI,CACvB,IAAIY,EAAIb,EAAKC,GACTa,EAAId,GAAMC,EAAM,GAAK,GAErBc,EAAKC,KAAKC,IAAIJ,EAAGC,GACjBI,EAAKF,KAAKG,IAAIN,EAAGC,GAErBtB,EAAOY,KAAKC,UAAU,CAACU,EAAIG,KAAQ,CAACH,EAAIG,KAKpD,IAAIE,EAAY,GAChB,IAAI,IAAMC,KAAK9B,EAAW,CAEtB6B,EADY7B,EAAW8B,IACN5B,EAAa4B,GAGlC,IAAIC,EAAQ,GAEZ,IAAK,IAAMrB,KAAOT,EAAQ,CAGtB,IAAMqB,EAAIrB,EAAOS,GAAK,GAChBa,EAAItB,EAAOS,GAAK,GAMhBsB,EAAiB,IAAIC,IAAUJ,EAAUP,GAAIO,EAAUN,IAI7DQ,EAAMG,KAAKF,GAGf,OAAOD,EAGX,SAASI,EAAwBpC,GAG7B,IAAIqC,EAAY,IAAIC,IAChBC,EAAkB,GAEtB,IAAK,IAAMnC,KAAYJ,EAAcK,YAAa,CAC9C,IACMC,EADMN,EAAcO,aAAaH,GACpBI,iBAEnB,GAAsB,IAAlBF,EAAOG,OACP,IAAK,IAAME,IAAO,CAAC,EAAE,EAAE,GAAI,CACvB,IAAMC,EAAON,EAAOK,GACpB4B,EAAgBJ,KAAKvB,EAAKI,GAC1BuB,EAAgBJ,KAAKvB,EAAKK,GAC1BsB,EAAgBJ,KAAK,KAKjC,IAAMK,EAAW,IAAIC,aAAcF,GAKnC,OAHAF,EAAUK,aAAc,WAAY,IAAIC,IAAiBH,EAAU,IACnEH,EAAUO,uBAEHP,EAGJ,SAASQ,EAAaC,EAAMC,GAAwB,IAAhBC,EAAe,uDAAJ,GAClD,OAAOC,IAASC,SAASJ,EAAMC,EAAQC,GA6BpC,SAASG,EAAqBC,EAAOC,GACxC,OAAOD,EAAME,WAAWD,GAGrB,SAASE,EAAuBH,EAAOC,GAC1C,OAAOD,EAAMI,aAAaH,GAcvB,SAASI,EAAcC,GAC1B,IAAMC,EA/BH,SAAyBD,GAC5B,OAAoB,IAAhBA,EAAKjD,OACEiD,EAAK,IAGD,IAAI5D,KACU8D,yBAAyBF,GAAMG,QAyBzCC,CAAgBJ,GAEnC,OAAOK,IAAaF,MAAMF,GAGvB,SAASK,IACZ,IAD4B,EAOtBN,EAxBH,SAAsBO,GACzB,IADkC,EAC5BC,EAAS,IAAIC,IACbT,EAAO,GAFqB,cAIZO,GAJY,IAIlC,2BAA+B,CAAC,IAArBG,EAAoB,QAC3BV,EAAKvB,KAAK+B,EAAOG,KAAKD,KALQ,8BAQlC,OAAOV,EAgBMY,CANG,CACZ,gBACA,eACA,iBAIAC,EAAe,GARS,cAUVb,GAVU,IAU5B,2BAAwB,CAAC,IAAdc,EAAa,QACpBD,EAAapC,KAAKc,IAASC,SAASsB,EAAK,GAAI,OAXrB,8BAgB5B,OAFaf,EAAcc,GAuBxB,SAASE,IACZ,OAnBG,SAA6BC,GAChC,IAAM1E,EAAgBT,EAAyBmF,GAE/C,MAAO,CACHC,OAAQvC,EAAwBpC,GAChC4E,MAAO7E,EAAuBC,IAc3B6E,CAAoBb,K,kBCxNlBc,EAAb,WAMI,WAAYC,EAAQC,GAAY,oBAC5BC,KAAKF,OAASA,EACdE,KAAKC,UAAW,IAAI5D,KAAU6D,KAAKJ,GACnCE,KAAKD,UAAYA,EATzB,wCAYI,SAAKI,GACDH,KAAKC,UAAW,IAAI5D,KAAU+D,WAC1BJ,KAAKC,UACL,IAAI5D,KAAUgE,gBAAgBL,KAAKD,UAAWI,MAf1D,iBAmBI,SAAIA,GACAH,KAAKC,UAAW,IAAI5D,KAAU+D,WAC1BJ,KAAKF,QACL,IAAIzD,KAAUgE,gBAAgBL,KAAKD,UAAWI,MAtB1D,0BA0BI,WACI,OAAO,IAAIG,IACPN,KAAKC,SAASlE,EACdiE,KAAKC,SAASjE,EACdgE,KAAKC,SAAShE,KA9B1B,uBAkCI,WACI,OAAO,IAAII,IAAQ2D,KAAKC,SAASlE,EAAGiE,KAAKC,SAAShE,GAAI+D,KAAKC,SAASjE,OAnC5E,K,2BCuCauE,GAvCuBC,IAoBJA,IAmBhC,kDACI,WAAYC,GAAwB,IAAD,EAAfC,IAAe,qFAC/B,gBAEKD,OAASA,EACd,EAAKC,OAASA,EAEd,EAAKC,OAN0B,EADvC,wCAUI,WACIX,KAAKY,KAAOZ,KAAKa,UAEjBb,KAAKc,mBAAqBd,KAAKe,kBAbvC,2BAgBI,WACI,OAAIf,KAAKU,OACEV,KAAKS,OAAOjF,OAEZwE,KAAKS,OAAOjF,OAAS,IApBxC,qBAwBI,WAGI,IAFA,IAAIwF,EAAU,GAELC,EAAI,EAAGA,EAAIjB,KAAKe,gBAAiBE,IAAK,CAC3C,IAAMzE,EAAKwD,KAAKS,OAAOQ,GACjBtE,EAAKqD,KAAKS,QAAQQ,EAAE,GAAKjB,KAAKe,iBAE9BG,GAAO,IAAI7E,KAAU8E,WAAWxE,EAAIH,GAE1CwE,EAAQ9D,KAAKgE,GAGjB,OAAOF,IApCf,uBAuCI,WACI,IAAMI,EAAUpB,KAAKqB,aACrB,OAAOD,EAAQA,EAAQ5F,OAAS,KAzCxC,wBA4CI,WACI,GAAKwE,KAAKsB,iBACJtB,KAAKsB,gBAAgB9F,SAAWwE,KAAKe,gBAAkB,IACvDf,KAAKuB,YAEP,OAAOvB,KAAKsB,gBAGhB,IAAIE,EAAW,EACfxB,KAAKsB,gBAAkB,CAACE,GATf,oBAWSxB,KAAKY,MAXd,IAWT,2BAA6B,CACzBY,GADyB,QACThG,SAChBwE,KAAKsB,gBAAgBpE,KAAKsE,IAbrB,8BAgBT,OAAOxB,KAAKsB,kBA5DpB,0BA+DI,SAAaG,GAAoC,IAAjCC,EAAgC,uDAAf,IAAIrF,IACjC,OAAO2D,KAAK2B,WAAWF,EAAIzB,KAAKe,gBAAiBW,KAhEzD,wBAmEI,SAAWE,GAAoC,IAQvCC,EARMH,EAAgC,uDAAf,IAAIrF,IACzByF,EAAOF,EAAI,EACbG,EAASH,EAAIA,EAAI,EAErB,GAAII,MAAMJ,GACN,OAAO,KAKX,GAAIA,EAAI,GAAKA,EAAI5B,KAAKe,gBAClB,GAAKe,EAAO,KAAQ,CAChB,IAAMnF,GAAK,IAAIN,KAAU6D,KAAKF,KAAKY,KAAKmB,IAClCvF,GAAK,IAAIH,KAAU6D,KAAKF,KAAKY,KAAKmB,EAAS,IAEjDvF,EAAGyF,YACHtF,EAAGsF,YAEHJ,GAAK,IAAIxF,KAAU+D,WAAW5D,EAAIG,QAElCkF,GAAK,IAAIxF,KAAU6D,KAAKF,KAAKY,KAAKmB,IAI1C,GAAI/B,KAAKU,OAGL,GAFAqB,GAAU/B,KAAKe,gBAEVe,EAAO,KAAQ,CAChB,IAAMnF,GAAK,IAAIN,KAAU6D,KAAKF,KAAKY,KAAKmB,IAClCvF,GAAK,IAAIH,KAAU6D,KAAKF,KAAKY,MAAMmB,EAAS/B,KAAKe,gBAAkB,GAAKf,KAAKe,kBAEnFvE,EAAGyF,YACHtF,EAAGsF,YAEHJ,GAAK,IAAIxF,KAAU+D,WAAW5D,EAAIG,QAElCkF,GAAK,IAAIxF,KAAU6D,KAAKF,KAAKY,KAAKmB,SAIlCF,EADAD,EAAI,GACC,IAAIvF,KAAU6D,KAAKF,KAAKY,KAAK,KAE7B,IAAIvE,KAAU6D,KAAKF,KAAKY,KAAKZ,KAAKY,KAAKpF,OAAS,IAK7D,OADAqG,EAAGI,YACIP,EAAeQ,IAAIL,EAAG9F,EAAG8F,EAAG7F,EAAG6F,EAAG5F,KAlHjD,iCAqHI,SAAqB8B,EAAU2C,GAe3B,IAXA,IAAMyB,EAAS,IAAI9F,IAEb+F,EAAW,GACXC,EAAU,GACVC,EAAY,GAEZC,EAAM,IAAIlG,IACVmG,EAAM,IAAIC,IAINxB,EAAI,EAAGA,GAAKlD,EAAUkD,IAAO,CAEnC,IAAMQ,EAAIR,EAAIlD,EAEdqE,EAAUnB,GAAMjB,KAAK0C,aAAcjB,EAAG,IAAIpF,KAO9CgG,EAAS,GAAM,IAAIhG,IACnBiG,EAAW,GAAM,IAAIjG,IACrB,IAAIK,EAAMiG,OAAOC,UACXC,EAAKpG,KAAKqG,IAAKV,EAAU,GAAIrG,GAC7BgH,EAAKtG,KAAKqG,IAAKV,EAAU,GAAIpG,GAC7BgH,EAAKvG,KAAKqG,IAAKV,EAAU,GAAInG,GAE9B4G,GAAMnG,IAEPA,EAAMmG,EACNV,EAAOD,IAAK,EAAG,EAAG,IAIjBa,GAAMrG,IAEPA,EAAMqG,EACNZ,EAAOD,IAAK,EAAG,EAAG,IAIjBc,GAAMtG,GAEPyF,EAAOD,IAAK,EAAG,EAAG,GAItBK,EAAIU,aAAcb,EAAU,GAAKD,GAASF,YAE1CI,EAAS,GAAIY,aAAcb,EAAU,GAAKG,GAC1CD,EAAW,GAAIW,aAAcb,EAAU,GAAKC,EAAS,IAKrD,IAAM,IAAIpB,EAAI,EAAGA,GAAKlD,EAAUkD,IAAO,CAQnC,GANAoB,EAASpB,GAAMoB,EAASpB,EAAI,GAAIiC,QAEhCZ,EAAWrB,GAAMqB,EAAWrB,EAAI,GAAIiC,QAEpCX,EAAIU,aAAcb,EAAUnB,EAAI,GAAKmB,EAAUnB,IAE1CsB,EAAI/G,SAAWmH,OAAOQ,QAAU,CAEjCZ,EAAIN,YAEJ,IAAMmB,EAAQ3G,KAAK4G,KAAMC,YAAOlB,EAAUnB,EAAI,GAAIsC,IAAKnB,EAAUnB,KAAS,EAAG,IAE7EoB,EAASpB,GAAIuC,aAAchB,EAAIiB,iBAAkBlB,EAAKa,IAI1Dd,EAAWrB,GAAIgC,aAAcb,EAAUnB,GAAKoB,EAASpB,IAMzD,IAAgB,IAAXP,EAAkB,CAEnB,IAAI0C,EAAQ3G,KAAK4G,KAAMC,YAAOjB,EAAS,GAAIkB,IAAKlB,EAAStE,KAAgB,EAAG,IAC5EqF,GAASrF,EAEJqE,EAAU,GAAImB,IAAKhB,EAAIU,aAAcZ,EAAS,GAAKA,EAAStE,KAAiB,IAE9EqF,GAAUA,GAId,IAAM,IAAInC,EAAI,EAAGA,GAAKlD,EAAUkD,IAG5BoB,EAASpB,GAAIuC,aAAchB,EAAIiB,iBAAkBrB,EAAUnB,GAAKmC,EAAQnC,IACxEqB,EAAWrB,GAAIgC,aAAcb,EAAUnB,GAAKoB,EAASpB,IAY7D,MAAO,CACHmB,SAAUA,EACVC,QAASA,EACTC,UAAWA,KAxOvB,4BA6OI,SAAeV,GACX,IAAIE,EAAOF,EAAI,EAEX8B,EAAK9B,EAAIE,EAcb,OAZI9B,KAAKU,OACLgD,GAAM1D,KAAKe,gBAEP2C,EAAK,GACL5B,GAAQ4B,EACRA,EAAK,GACEA,GAAM1D,KAAKe,kBAClBe,GAAQ4B,EAAK1D,KAAKe,gBAClB2C,EAAK1D,KAAKe,iBAIX,CACHe,KAAMA,EACN4B,GAAIA,KAhQhB,wBAoQI,SAAW9B,GAAqC,IAAlCF,EAAiC,uDAAhB,IAAIrF,IAC/B,OAAO2D,KAAK2D,SAAS/B,EAAGF,KArQhC,sBAwQI,SAAUE,GAAqC,IAAlCF,EAAiC,uDAAhB,IAAIrF,IAC9BuF,GAAK5B,KAAKe,gBAEV,MAAmBf,KAAK4D,eAAehC,GAAhCE,EAAP,EAAOA,KAAM4B,EAAb,EAAaA,GAEPlH,EAAKwD,KAAKS,OAAOiD,GACjBxC,EAAOlB,KAAKY,KAAK8C,GAEjB5G,GAAI,IAAIT,KAAU+D,WAAW5D,GAAI,IAAIH,KAAUgE,gBAAgBa,EAAMY,IAE3E,OAAOJ,EAAeQ,IAAIpF,EAAEf,EAAGe,EAAEd,EAAGc,EAAEb,KAlR9C,0BAqRI,WAA0B,IAAD,EAAZ4H,EAAY,uDAAH,EAAG,cACD7D,KAAKS,QADJ,IACrB,2BAAiC,CAAC,IAAvBqD,EAAsB,QAC7BA,EAAM9H,EAAI6H,GAFO,iCArR7B,wBA2RI,WAII,IAJsC,IAA/BE,EAA8B,uDAApB,EAAIC,EAAgB,uDAAJ,EAC3BC,EAAkB,EAAVF,EAAetH,KAAKyH,GAAMlE,KAAKe,gBACzCoD,EAAQ,EAEHlD,EAAI,EAAGA,EAAIjB,KAAKe,gBAAiBE,IACtCjB,KAAKS,OAAOQ,GAAGhF,GAAK+H,EAAYvH,KAAK2H,IAAID,GACzCA,GAASF,EAGbjE,KAAKW,SApSb,qBAuSI,WAAW,IAAD,gBACWX,KAAKS,QADhB,IACN,2BAA8B,CAAC,IAApB4D,EAAmB,QAC1BA,EAAGnC,IAAImC,EAAGtI,EAAGsI,EAAGpI,GAAIoI,EAAGrI,IAFrB,mCAvSd,GAA8BwE,MC1CvB,SAAS8D,EAAiBC,EAAIC,GACjC,IAAML,EAAQK,EAAWC,WAAaF,EAAGvI,EACzC,OAAOS,KAAK2H,IAAIG,EAAGxI,EAAIU,KAAKyH,GAAKM,EAAWE,OAASP,GAASK,EAAWR,UAAYQ,EAAWG,OAoDpG,SAASC,EAAiBL,EAAIC,GAC1B,MAjDJ,SAAkBD,EAAIC,GAClB,IAAIK,EAAQC,EAoBZ,OAlBAD,GAAUN,EAAGxI,EAAIyI,EAAWO,MAAQP,EAAWQ,UAAYR,EAAWQ,SAAiC,GAAtBR,EAAWQ,SAC5FF,GAAUP,EAAGvI,EAAIwI,EAAWS,MAAQT,EAAWU,UAAYV,EAAWU,SAAiC,GAAtBV,EAAWU,SAExFV,EAAWW,eACL1I,KAAKqG,IAAI+B,GAAUL,EAAWQ,SAAWvI,KAAKqG,IAAIgC,GAAUN,EAAWU,SAAa,KAElFL,EADAA,EAAS,EACuB,IAAtBL,EAAWQ,SAAgBH,EAEN,GAAtBL,EAAWQ,SAAgBH,EAGpCC,EADAA,EAAS,EACuB,IAAtBN,EAAWU,SAAgBJ,EAEN,GAAtBN,EAAWU,SAAgBJ,GAKzC,CACHD,OAAQA,EACRC,OAAQA,GA0BWM,CAASb,EAAIC,GAA/BK,EAAL,EAAKA,OAAQC,EAAb,EAAaA,OAEbA,GAAUN,EAAWa,aAErB,IAAMC,EAAgB7I,KAAK8I,KAAKV,EAASA,EAASC,EAASA,GAE3D,OAAIQ,EAAgBd,EAAW1G,OACpB,EAEA,EAAKwH,EAAgBd,EAAW1G,OAmBxC,SAAS0H,EAAmBjB,EAAIkB,GACnC,IAAMjK,EAAS+I,EAAGxI,EAClB,OAAIP,GAAUiK,EAAiBC,UAAYlK,GAAUiK,EAAiBE,YAC3D,EACAnK,GAAUiK,EAAiBG,eAAiBpK,GAAUiK,EAAiBI,aACvE,EACArK,EAASiK,EAAiBG,gBACzBpK,EAASiK,EAAiBE,aAAeF,EAAiBK,YAC3DtK,EAASiK,EAAiBI,aAC1B,GAAMrK,EAASiK,EAAiBI,cAAgBJ,EAAiBK,YAEjE,KAyBR,IAAMC,EAAiC,CAC1C/B,UAAW,CAACgC,QAAS,EAAItJ,IAAK,EAAIE,IAAK,IACvC8H,OAAQ,CAACsB,QAAS,GAAKtJ,IAAK,GAAKE,IAAK,KACtC6H,WAAY,CAACuB,QAAS,EAAItJ,KAAM,GAAKE,IAAK,IAC1C+H,OAAQ,CAACqB,QAAS,EAAItJ,KAAM,GAAKE,IAAK,IACtC2H,GAAI,CAACyB,QAAS,EAAGtJ,IAAK,EAAGE,IAAK,IAGrBqJ,EAA4B,CACrClB,MAAO,CAACiB,QAAS,EAAItJ,KAAM,IAAME,IAAK,KACtCqI,MAAO,CAACe,QAAS,EAAItJ,KAAM,IAAME,IAAK,KACtCoH,UAAW,CAACgC,QAAS,GAAKtJ,KAAM,GAAKE,IAAK,IAC1CoI,SAAU,CAACgB,QAAS,GAAKtJ,IAAK,EAAIE,IAAK,KACvCsI,SAAU,CAACc,QAAS,GAAKtJ,IAAK,EAAIE,IAAK,KACvCkB,OAAQ,CAACkI,QAAS,GAAKtJ,IAAK,EAAIE,IAAK,IACrCyI,aAAc,CAACW,QAAS,EAAItJ,IAAK,EAAIE,IAAK,IAC1CuI,cAAe,CAACa,QAAS,EAAItJ,IAAK,EAAGE,IAAK,IAC1C2H,GAAI,CAACyB,QAAS,EAAGtJ,IAAK,EAAGE,IAAK,IAgBrBsJ,EAAe,CACxB5B,iBAAkB,CACd6B,kBAAmBJ,EACnBK,gBAAiB9B,GAErB+B,oBAAqB,CACjBF,kBAAmBF,EACnBG,gBA3FD,SAA6B7B,EAAIC,GAEpC,OADkBI,EAAiBL,EAAIC,GACpBA,EAAWR,YA2F9BsC,sBAAuB,CACnBH,kBAAmBF,EACnBG,gBA1FD,SAA+B7B,EAAIC,GACtC,IAAM+B,EAAY3B,EAAiBL,EAAIC,GACvC,OAAO/H,KAAK8I,KAAK,WAAM,EAAKgB,EAAc,IAAK/B,EAAWR,YA0F1DwC,oBAAqB,CACjBL,kBAAmBF,EACnBG,gBAzFD,SAA6B7B,EAAIC,GACpC,IAAM+B,EAAY3B,EAAiBL,EAAIC,GACvC,OAAQ,EAAK/H,KAAK8I,KAAK,WAAKgB,EAAa,KAAM/B,EAAWR,YAyF1DyC,mBAAoB,CAChBN,kBA/BsC,CAC1CpB,MAAO,CAACiB,QAAS,EAAItJ,KAAM,IAAME,IAAK,KACtCqI,MAAO,CAACe,QAAS,EAAItJ,KAAM,IAAME,IAAK,KACtCoH,UAAW,CAACgC,QAAS,GAAKtJ,KAAM,GAAKE,IAAK,IAC1CiH,OAAQ,CAACmC,QAAS,GAAKtJ,IAAK,EAAIE,IAAK,KACrCoI,SAAU,CAACgB,QAAS,GAAKtJ,IAAK,EAAIE,IAAK,KACvCsI,SAAU,CAACc,QAAS,GAAKtJ,IAAK,EAAIE,IAAK,KACvC8J,QAAS,CAACV,QAAS,IAAKtJ,IAAK,EAAIE,IAAK,IACtC+J,QAAS,CAACX,QAAS,GAAKtJ,IAAK,EAAIE,IAAK,IACtCuI,cAAe,CAACa,QAAS,EAAItJ,IAAK,EAAGE,IAAK,IAC1C2H,GAAI,CAACyB,QAAS,EAAGtJ,IAAK,EAAGE,IAAK,IAsB1BwJ,gBAzED,SAA4B7B,EAAIC,GACnC,IAKIoC,EALJ,EAlEJ,SAA0BrC,EAAIC,GAC1B,IAAIK,EAAQC,EAcZ,OAZAD,GAAUN,EAAGxI,EAAIyI,EAAWO,MAAQP,EAAWQ,UAAYR,EAAWQ,SACtEF,GAAUP,EAAGvI,EAAIwI,EAAWS,MAAQT,EAAWU,UAAYV,EAAWU,SAAiC,GAAtBV,EAAWU,SAExFV,EAAWW,eACP1I,KAAKoK,OAAOtC,EAAGvI,EAAI8I,GAAUN,EAAWU,UAAY,IAAO,IAC3DL,GAAgC,GAAtBL,EAAWQ,SACrBH,GAAUL,EAAWQ,UAMtB,CACHH,OAHJA,GAAgC,GAAtBL,EAAWQ,SAIjBF,OAAQA,GAiDWgC,CAAiBvC,EAAIC,GAAvCK,EAAL,EAAKA,OAAQC,EAAb,EAAaA,OAEPiC,EAAKvC,EAAWmC,QAAUnC,EAAWkC,QAW3C,OATA7B,EAASpI,KAAKqG,IAAI+B,KAId+B,EADAnK,KAAKqG,IAAIgC,GAAU,KAA4B,GAApBN,EAAWX,OAC7BW,EAAWkC,QAAUK,GAAMjC,EAASN,EAAWX,OAAS,KAEvD,GAIH,EAEA,SAAC,WAAKgB,EAAS+B,EAAW,GAAO,IAAKpC,EAAWR,aC7GnDgD,EAAb,WAGI,WAAYC,GAAa,oBACrBjH,KAAKiH,WAAaA,EAJ1B,6CAOI,WACI,IADQ,EACJC,EAAa,GADT,cAGSlH,KAAKiH,YAHd,IAGR,2BAAkC,CAAC,IAAxB5C,EAAuB,QAC9B6C,EAAYhK,KAAKmH,EAAG8C,iBAJhB,8BASR,OAFAD,EAAYhK,KAAKgK,EAAY,KAEtB,IAAIrM,KAAkBuM,cAAcF,KAhBnD,wBAmBI,WACI,IADS,EACLG,EAAY,GADP,cAGQrH,KAAKiH,YAHb,IAGT,2BAAkC,CAAC,IAAxB5C,EAAuB,QAC9BgD,EAAUnK,KAAKmH,EAAGiD,cAJb,8BAOT,OAAO,IAAI/G,EAAS8G,KA1B5B,0BA6BI,WAA2B,IAAD,EAAbxD,EAAa,uDAAJ,EAAI,cACL7D,KAAKiH,YADA,IACtB,2BAAkC,CAAC,IAAxB5C,EAAuB,QAC9BA,EAAGpI,EAAI4H,GAFW,iCA7B9B,0BAmCI,SAAauC,EAAiB5B,GAAsC,IAA1BiB,EAAyB,uDAAN,KACzD,GAAIjB,EAAWD,GAAI,CAAC,IAAD,gBACEvE,KAAKiH,YADP,IACf,2BAAkC,CAAC,IAAxB5C,EAAuB,QAC9B,GAAIoB,EAAkB,CAClB,IAAM8B,EAAY/B,EAAmBnB,EAAGmD,QAAS/B,GAC/B,IAAd8B,GACAlD,EAAGnC,IAAIkE,EAAgB/B,EAAGmD,QAAShD,GAAc+C,QAGrDlD,EAAGnC,IAAIkE,EAAgB/B,EAAGmD,QAAShD,KAR5B,mCAWZ,CAAC,IAAD,gBACcxE,KAAKiH,YADnB,IACH,2BAAkC,CAAC,IAAxB5C,EAAuB,QAC9BA,EAAGnC,IAAIkE,EAAgB/B,EAAGvE,OAAQ0E,KAFnC,kCA/Cf,6BAsDI,WACI,IADc,EACV6C,EAAY,GADF,cAGGrH,KAAKiH,YAHR,IAGd,2BAAkC,CAAC,IAAxB5C,EAAuB,QAC9BgD,EAAUnK,KAAKmH,EAAGiD,cAJR,8BAOd,OAAO,IAAI/G,EAAS8G,OA7D5B,MCDY,IAAIxM,KAAkB4M,mBAelC,SAASC,EAAqB9L,GAC1B,IAAI+L,EAQJ,OALIA,EADA3F,MAAMpG,EAAWK,GACV,EAEAL,EAAWK,EAGf,IAAII,IACPT,EAAWG,EACX4L,GACC/L,EAAWI,GAIpB,SAAS4L,EAAqBC,GAC1B,IADsC,EAClCC,EAAU,GADwB,cAGbD,EAAWtM,kBAHE,IAGtC,2BAAsD,CAAC,IAA5CK,EAA2C,QAClDkM,EAAQ5K,KAAKwK,EAAqB9L,KAJA,8BAStC,OAFAkM,EAAQC,MAED,IAAIxH,EAASuH,GAGjB,SAASE,EAAmBzN,GAC/B,IAAI0N,EAAY,GAEhB,GAAiC,iBAA7B1N,EAAQ2N,YAAYC,KAAyB,CAAC,IAAD,gBAC5B5N,EAAQa,aADoB,IAC7C,2BAAsC,CAAC,IAAD,EAA3BgN,EAA2B,sBACjBJ,EAAmBI,IADF,IAClC,2BAAwC,CAAC,IAA9BC,EAA6B,QACpCJ,EAAU/K,KAAKmL,IAFe,gCADO,8BAO7C,OAAOJ,EAGX,IAbuC,EAajCK,EAtDV,SAAwB/N,GACpB,IAAIgO,EAAc,GAClBA,EAAYrL,KAAK3C,EAAQiO,mBAIzB,IAAK,IAAIvH,EAAI,EAAGA,EAAI1G,EAAQkO,qBAAsBxH,IAC9CsH,EAAYrL,KAAK3C,EAAQmO,iBAAiBzH,IAG9C,OAAOsH,EA4CKI,CAAepO,GAbY,cAetB+N,GAfsB,IAevC,2BAAqB,CAAC,IAAXM,EAAU,QACjBX,EAAU/K,KAAK0K,EAAqBgB,KAhBD,8BAmBvC,OAAOX,E,WChDJ,SAASY,EAAkBC,GAC9B,IAIMvO,GAJa,IAAIM,KAIIuM,cAjB/B,SAAiC0B,GAC7B,IADuC,EAJdC,EAKrB7B,EAAc,GADqB,cAGtB4B,EAASrI,QAHa,IAGvC,2BAAkC,CAAC,IAAxB4D,EAAuB,QAC9B6C,EAAYhK,MARS6L,EAQgB1E,EAPlC,IAAI/D,IAAWyI,EAAQhN,EAAGgN,EAAQ/M,EAAG+M,EAAQ9M,MAGb,8BASvC,OAFAiL,EAAYhK,KAAKgK,EAAY,IAEtBA,EAQkC8B,CAAwBF,IAEjE,OAAOvO,ECFJ,SAAS0O,EAAOC,EAAOC,EAAUC,GACpC,GAAKF,GAAUC,GAAaC,EAA5B,CAGA,MAAoCF,EAAMG,QAAnCC,EAAP,EAAOA,YAAaC,EAApB,EAAoBA,aAEhBH,IACAA,EAAOI,OAASF,EAAcC,EAC9BH,EAAOK,0BAGXN,EAASO,QAAQJ,EAAaC,I,IC1BvBI,EACAR,E,SCVJ,SAASS,EAAMT,EAAUQ,EAAOP,GAEnC,IAAMS,EAAU,CAACA,QAAS,MAI1B,OAFAA,EAAQA,QAAUC,uBAAsB,kBAAMC,EAAQZ,EAAUQ,EAAOP,EAAQS,MAExEA,EAOX,SAASE,EAAQZ,EAAUQ,EAAOP,EAAQS,GACtCV,EAASa,MAAM,QACfb,EAASc,OAAON,EAAOP,GAEvBS,EAAQA,QAAUC,uBAAsB,kBAAMC,EAAQZ,EAAUQ,EAAOP,EAAQS,MDL5E,SAASK,EAAMhB,GAClBS,EAAQ,IAAIQ,IAEZ,IAAMC,EE+FH,WACH,IAAMC,EAAmB,IAAIC,IAAkB,SAAU,KAWzD,OAVAD,EAAiBpK,SAASiC,IAAI,IAAI,IAAI,KAEtCmI,EAAiBE,YAAa,EAC9BF,EAAiBG,OAAOpB,OAAOqB,KAAO,KACtCJ,EAAiBG,OAAOpB,OAAOsB,IAAM,KACrCL,EAAiBG,OAAOG,KAAO,KAE/BN,EAAiBG,OAAOI,QAAQC,MAAQ,KACxCR,EAAiBG,OAAOI,QAAQ/G,OAAS,KAElCwG,EF3GOS,GACdnB,EAAMoB,IAAIX,GAEVY,KAEAxL,IAEA2J,EDVG,WACH,IAAMA,EAAW,IAAI8B,IAAe,CAACC,WAAW,EAAMC,OAAO,IAQ7D,OALAhC,EAASiC,cAAcC,OAAOC,kBAE9BnC,EAASoC,UAAUC,SAAU,EAC7BrC,EAASoC,UAAUE,KAAOC,IAEnBvC,ECCIwC,GACXzC,EAAMG,QAAQuC,YAAYzC,EAAS0C,YAInC,IAAMzC,EGPH,SAA8BF,GACjC,IAAOI,EAA6BJ,EAA7BI,YAAaC,EAAgBL,EAAhBK,aAEdH,EAAS,IAAI0C,IACf,GACAxC,EAAcC,GAIlB,OADAH,EAAOnJ,SAAShE,EAAI,IACbmN,EHFQ2C,CAAqB7C,EAAMG,SAC1CM,EAAMoB,IAAI3B,GAEV,IAAM4C,EI3BH,SAA0B5C,EAAQD,GACrC,IAAM6C,EAAgB,IAAIC,IAAc7C,EAAQD,EAAS0C,YAUzD,OATAG,EAAcE,cAAe,EAC7BF,EAAcG,YAAa,EAK3BH,EAAcI,OAAOlK,IAAI,EAAG,GAC5B8J,EAAcK,SAEPL,EJgBeM,CAAiBlD,EAAQD,GAE/CF,EAAOC,EAAOC,EAAUC,GACxB,IAAMS,EAAUD,EAAMT,EAAUQ,EAAOP,GAEvC,MAAO,CACHO,MAAOA,EACPR,SAAUA,EACVC,OAAQA,EACRS,QAASA,EACTmC,cAAeA,GAIhB,SAASO,EAAQrD,EAAOC,EAAUU,ICnClC,YAA0B,IAAXA,EAAU,EAAVA,QACX2C,qBAAqB3C,GDmC5B4C,CAAK5C,EAAQA,SACbX,EAAMG,QAAQqD,YAAYvD,EAAS0C,YEvCvC,IAGWc,EADAC,EAAgB,GAGdC,EAAqB,CAC9BC,gBAAiB,CAAC9G,QAAS,IAAKtJ,IAAK,EAAIE,IAAK,IAC9CmQ,UAAW,CAAC/G,QAAS,IAAOtJ,IAAK,IAAME,IAAK,KAC5CoQ,WAAY,CAAChH,QAAS,IAAOtJ,IAAK,IAAME,IAAK,KAC7CqQ,uBAAwB,CAACjH,QAAS,EAAKtJ,IAAK,EAAKE,IAAK,IACtDsQ,WAAY,CAAClH,QAAS,IAAOtJ,IAAK,IAAME,IAAK,KAC7CuQ,aAAc,CAACnH,QAAS,GAAMtJ,IAAK,GAAKE,IAAK,KAC7CwQ,cAAe,CAACpH,QAAS,IAAOtJ,IAAK,GAAKE,IAAK,KAC/CyQ,aAAc,CAACrH,QAAS,EAAGtJ,IAAK,EAAGE,IAAK,GACxC0Q,aAAc,CAACtH,QAAS,GAAMtJ,IAAK,GAAKE,IAAK,KAC7C2Q,aAAc,CAACvH,QAAS,GAAMtJ,IAAK,GAAKE,IAAK,KAC7C4Q,SAAU,CAACxH,QAAS,IAAOtJ,IAAK,EAAKE,IAAK,IAC1C6Q,aAAc,CAACzH,QAAS,GAAItJ,IAAK,EAAKE,IAAK,IAC3C8Q,UAAW,CAAC1H,QAAS,EAAKtJ,IAAK,EAAKE,IAAK,IACzC+Q,WAAY,CAAC3H,QAAS,IAAOtJ,IAAK,EAAKE,IAAK,IAC5CgR,YAAa,CAAC5H,QAAS,IAAOtJ,IAAK,EAAKE,IAAK,IAC7CiR,YAAa,CAAC7H,SAAU,IAAOtJ,IAAK,EAAKE,IAAK,IAC9CkR,YAAa,CAAC9H,QAAS,IAAKtJ,IAAK,EAAKE,IAAK,IAC3CmR,YAAa,CAAC/H,QAAS,GAAKtJ,IAAK,EAAIE,IAAK,KAC1CoR,UAAW,CAAChI,QAAS,IAAMtJ,IAAK,EAAIE,IAAK,KACzCqR,QAAS,CACL7H,gBAAiB,CAACJ,QAAS1B,GAC3B6B,kBAAmB,CAACH,QAASD,KAuBrC,SAASmI,IACL,IAAIC,EAAuB,GAE3B,IAAK,IAAMC,KAAOvB,EAAmBoB,QAAQ9H,kBAAkBH,QAC3DmI,EAAqBC,GAAOvB,EAAmBoB,QAAQ9H,kBAAkBH,QAAQoI,GAAKpI,QAG1F,OAAOmI,EAiEJ,SAASE,KACZ,IAAMC,EAJC3B,EAAWI,UAAYtQ,KAAKyH,GAAsD,GAAhDyI,EAAWK,WAAaL,EAAWI,WAc5E,OARAJ,EAAWlH,iBAAmB,CAC1BE,YAAagH,EAAWoB,YACxBnI,eAAgB+G,EAAWqB,UAC3BnI,aAA+B,GAAjByI,EAAsB3B,EAAWqB,UAC/CtI,UAA4B,GAAjB4I,EAAsB3B,EAAWoB,YAC5CjI,YAAa,GAAM6G,EAAWqB,UAAYrB,EAAWoB,cAGlDpB,EAeJ,SAAS3B,MAZT,SAAoBrB,GAAO,IAAD,gBACXiD,GADW,IAC7B,2BAAiC,CAAC,IAAvB2B,EAAsB,QAC7B5E,EAAM6E,OAAOD,GACbA,EAAIE,SAASC,UACbH,EAAII,SAASD,WAJY,8BAO7BE,QAAQC,IAAIlF,GAEZiD,EAAgB,GAKhBkC,CAAWnF,GAEX0E,KAEAO,QAAQC,IAAIlC,GAEZ,IAAMoC,EAAMC,GAAerC,IA9F/B,SAA0BhD,EAAOoF,EAAKvK,GAClC,IAAMyK,EAAS,IAAIC,IAEbC,EAAsC,GAAzB3K,EAAWsJ,YAE9BmB,EAAOG,KAnEc,gEAwEjB,SAAWC,GAEP,IAFiB,EAEXC,EAAc,IAAIC,IAAqB,CACzCC,IAAKH,IAHQ,cAQAN,GARA,IAQjB,2BAAsB,CAAC,IAAZ1G,EAAW,QACZoH,EAAU,IAAIC,IAAarH,EAAIA,EAAGtH,gBAAiBoO,EAAY,GAAG,GAClEQ,EAAU,IAAIC,IAAKH,EAASH,GAElCK,EAAQpF,YAAa,EACrBoF,EAAQE,eAAgB,EAExBjD,EAAc1P,KAAKyS,GAEnBhG,EAAMoB,IAAI4E,IAjBG,sCAsBrBG,GAGA,SAAWC,GACPnB,QAAQoB,MAAO,yBA4DvBC,CAAiBtG,EAAOoF,EAAKpC,GGxJjC,SAASuD,GAAkBC,EAAGtM,GAC1B,OAAOsM,EAAEC,iBAAmBvM,EAASsM,EAAE7C,aAG3C,SAAS+C,GAAUpP,EAAGqP,EAAYC,EAAYzS,EAAQ0S,GAAuB,IAAZC,EAAW,uDAAJ,EAC9DC,EAAYH,EAAatP,EACzB0P,EAAQL,EAAaI,EAErBE,EAAKnU,KAAKoU,IAAIF,GACdG,EAAKrU,KAAK2H,IAAIuM,GAEd5U,EAAI+B,EAAS8S,EACb5U,EAAI8B,EAASgT,EAEbC,EAAY,IAAIlR,EAClB,IAAIxD,IAAQmU,EAAUzU,EAAIA,EAAGyU,EAAUxU,EAAIA,EAAGwU,EAAUvU,GACxD,IAAII,IAAQuU,EAAIE,EAAI,IAKxB,OAFAC,EAAUvJ,QAAU,IAAIwJ,IAAQP,EAAOC,EAAY5S,EAAQ0S,EAAUvU,GAE9D8U,EAGX,SAASE,GAAanT,EAAQoT,EAAYC,EAAUb,EAAYE,EAAWvJ,GAIvE,IAJ+F,IAAZwJ,EAAW,uDAAJ,EACpFW,EAAQ3U,KAAK4U,KAAKF,EAAWrT,EAASoT,GACtCX,EAAaY,EAAWC,EAErBnQ,EAAI,EAAGA,EAAImQ,EAAOnQ,IAAK,CAC5B,IAAM8P,EAAYV,GAAUpP,EAAGqP,EAAYC,EAAYzS,EAAQ0S,EAAWC,GAC1ExJ,EAAW/J,KAAK6T,GAGpB,OAAOI,EAAWrT,EAAS2S,EAG/B,SAASa,GAAc9U,EAAIG,EAAIuU,EAAYjK,GAavC,IAb+D,IAAZwJ,EAAW,uDAAJ,EACpDjV,EAASgB,EAAG+U,WAAW5U,GACvByU,EAAQ3U,KAAK4U,KAAM7V,EAAS0V,GAE5BM,GAAQ,IAAInV,KAAUgE,iBACxB,IAAIhE,KAAU8E,WAAWxE,EAAIH,GAC7B,EAAK4U,GAGHK,EAAcD,EAAMhW,SAEpB2G,EAAS,IAAI9F,IAAQmV,EAAMxV,EAAIyV,GAAcD,EAAMzV,EAAI0V,GAEpDxQ,EAAI,EAAGA,EAAImQ,EAAOnQ,IAAK,CAC5B,IAAMnE,GAAI,IAAIT,KAAU+D,WACpB5D,GACA,IAAIH,KAAUgE,gBAAgBmR,EAAOvQ,IAGnC8P,EAAY,IAAIlR,EAAU/C,EAAGqF,GACnC4O,EAAUvJ,QAAU,IAAIwJ,IAAQP,EAAOxP,EAAIwQ,EAAajV,EAAGP,GAC3DgL,EAAW/J,KAAK6T,GAGpB,OAAOvV,EAASiV,EAGb,SAASiB,GAAavB,GAAiB,IAAdtM,EAAa,uDAAJ,EAC/BrH,EAAK,IAAIH,IAAwC,KAA9B8T,EAAEnD,WAAamD,EAAEpD,WAAiB,EAAKlJ,GAC1DlH,EAAK,IAAIN,IAAuC,IAA9B8T,EAAEnD,WAAamD,EAAEpD,WAAiB,EAAKlJ,GAE3DoD,EAAa,GAEbwJ,EAAO,EAEXA,EAAOQ,GAA2B,GAAdd,EAAEpD,UAAgBoD,EAAEzC,UAAW,GAAKjR,KAAKyH,GAAIzH,KAAKyH,GAAI1H,EAAIyK,EAAYwJ,GAE1F,IAAMkB,EAAK,IAAItV,IAAwC,KAA9B8T,EAAEnD,WAAamD,EAAEpD,WAAgC,IAAdoD,EAAEpD,UAAgBlJ,GACxE+N,EAAK,IAAIvV,IAAuC,IAA9B8T,EAAEnD,WAAamD,EAAEpD,WAAgC,IAAdoD,EAAEpD,UAAgBlJ,GAE7E4M,EAAOa,GAAcK,EAAIC,EAAIzB,EAAEzC,UAAWzG,EAAYwJ,GAEtDA,EAAOQ,GAA2B,GAAdd,EAAEpD,UAAgBoD,EAAEzC,UAAWjR,KAAKyH,IAAK,GAAIzH,KAAKyH,GAAIvH,EAAIsK,EAAYwJ,GAE1F,IAAMoB,EAAK,IAAIxV,IAAuC,IAA9B8T,EAAEnD,WAAamD,EAAEpD,WAA+B,GAAdoD,EAAEpD,UAAgBlJ,GACtEiO,EAAK,IAAIzV,IAAwC,KAA9B8T,EAAEnD,WAAamD,EAAEpD,WAA+B,GAAdoD,EAAEpD,UAAgBlJ,GAE7E4M,EAAOa,GAAcO,EAAIC,EAAI3B,EAAEzC,UAAWzG,EAAYwJ,GAEtDQ,GAA2B,GAAdd,EAAEpD,UAAgBoD,EAAEzC,UAAW,GAAKjR,KAAKyH,GAAI,GAAKzH,KAAKyH,GAAI1H,EAAIyK,EAAYwJ,GAExF,IAAMsB,EAAe,IAAI/K,EAAiBC,GAE1C,OAAO8K,EAGX,SAASC,GAAkBxV,EAAIG,EAAIsV,GAA8B,IAAnBC,EAAkB,wDACtDV,GAAQ,IAAInV,KAAUgE,iBACxB,IAAIhE,KAAU8E,WAAWxE,EAAIH,GAC7B,EAAKyV,GAGLE,EAAK,GAELvI,EAAQ,EACRwI,EAAMH,EAAY,EAEjBC,IACDtI,EAAQ,EACRwI,EAAMH,GAGV,IAAK,IAAIhR,EAAI2I,EAAO3I,EAAImR,EAAKnR,IAAK,CAC9B,IAAMnE,GAAI,IAAIT,KAAU+D,WACpB5D,GACA,IAAIH,KAAUgE,gBAAgBmR,EAAOvQ,IAGzCkR,EAAGjV,KAAKJ,GAGZ,OAAOqV,EAGX,SAASE,GAAkBpN,EAAOnH,GAK9B,IAL4F,IAAtDqT,EAAqD,uDAA1C1U,KAAKyH,GAAIoM,EAAiC,uDAApB,EAAIgC,EAAgB,uDAAL,IAChFd,EAAQL,EAAWmB,EAErBH,EAAK,GAEAlR,EAAI,EAAGA,EAAIqR,EAAUrR,IAAK,CAC/B,IAAM0P,EAAQL,EAAarP,EAAIuQ,EAEzBzV,EAAI+B,EAASrB,KAAKoU,IAAIF,GACtB3U,EAAI8B,EAASrB,KAAK2H,IAAIuM,GAE5BwB,EAAGjV,KAAK,IAAIb,IAAQ4I,EAAMlJ,EAAIA,EAAGkJ,EAAMjJ,EAAIA,EAAG,IAGlD,OAAO,IAAIuE,EAAS4R,GAGxB,SAASI,GAAgBpC,EAAGqC,GACxB,OAAO,IAAIjS,EAAS,CAChB,IAAIlE,IAAQmW,EAAOzW,EAAqB,GAAjBoU,EAAEhD,aAAmBqF,EAAOxW,EAAG,GACtD,IAAIK,IAAQmW,EAAOzW,EAAGyW,EAAOxW,EAAsB,GAAlBmU,EAAE/C,cAAoB,GACvD,IAAI/Q,IAAQmW,EAAOzW,EAAqB,GAAjBoU,EAAEhD,aAAmBqF,EAAOxW,EAAG,GACtD,IAAIK,IAAQmW,EAAOzW,EAAGyW,EAAOxW,EAAsB,GAAlBmU,EAAE/C,cAAoB,KAI/D,SAASqF,GAAUD,EAAQ3H,EAAOhH,GAC9B,OAAO,IAAItD,EAAS,CAChB,IAAIlE,IAAQmW,EAAOzW,EAAY,GAAR8O,EAAY2H,EAAOxW,EAAI,GAAK6H,EAAQ,GAC3D,IAAIxH,IAAQmW,EAAOzW,EAAY,GAAR8O,EAAY2H,EAAOxW,EAAI,GAAK6H,EAAQ,GAC3D,IAAIxH,IAAQmW,EAAOzW,EAAY,GAAR8O,EAAY2H,EAAOxW,EAAI,GAAM6H,EAAQ,GAC5D,IAAIxH,IAAQmW,EAAOzW,EAAY,GAAR8O,EAAY2H,EAAOxW,EAAI,GAAM6H,EAAQ,KAI7D,SAAS6O,GAAiBlW,EAAIG,EAAIwT,GAAiB,IAAD,EAAbtM,EAAa,uDAAJ,EAE3C8O,EAAYX,GAAkBxV,EAAIG,EAAIwT,EAAE9C,aAAe,GAAG,GAE5D0B,EAAM,GAJ2C,cAM9B4D,GAN8B,IAMrD,2BAAkC,CAAC,IAAxBC,EAAuB,QACxBC,EAAUN,GAAgBpC,EAAGyC,GAC7BE,EAAcL,GAAUG,EAAUzC,EAAErD,gBAAiBqD,EAAEpD,UAAYoD,EAAElD,wBAE3E8B,EAAI7R,KAAK2V,GACT9D,EAAI7R,KAAK4V,IAXwC,8BAcrD,IAAMC,EAAc7C,GAAkBC,EAAGtM,GAEzCkL,EAAI7R,KAAKmV,GAAkB7V,EAAkB,GAAduW,EAAkB,EAAKtW,KAAKyH,GAAI,EAAIiM,EAAE1C,eACrEsB,EAAI7R,KAAKmV,GAAkB1V,EAAkB,GAAdoW,EAAkB,EAAKtW,KAAKyH,GAAI,EAAIiM,EAAE1C,eACrEsB,EAAI7R,KAAKuV,GAAUjW,EAAI2T,EAAErD,gBAAiBqD,EAAEpD,UAAYoD,EAAElD,yBAC1D8B,EAAI7R,KAAKuV,GAAU9V,EAAIwT,EAAErD,gBAAiBqD,EAAEpD,UAAYoD,EAAElD,yBAC1D8B,EAAI7R,KAAKuV,GAAU,IAAIpW,IAAQ,EAAG,EAAG,GAAG8T,EAAEnD,WAAamD,EAAEpD,WAAaoD,EAAElD,uBAAyB,GAAKkD,EAAErD,kBAGxG,IADA,IAAIkG,EAAW,GACf,MAAiBjE,EAAjB,eAAqB,CAAhB,IAAM1G,EAAE,KACT2K,EAAS9V,KAAK2L,EAAkBR,IAGpC,IAAMxK,EAAOW,EAAcwU,GAE3B,OAAOnV,EAeJ,SAASoV,GAAOzW,EAAIG,EAAIwT,GAAiB,IAAdtM,EAAa,uDAAJ,EACjCqP,EAAiBxB,GAAavB,EAAGtM,GAEvCqP,EAAeC,aACXhD,EAAElC,QAAQ7H,gBACV+J,EAAElC,QAAQ9H,kBACVgK,EAAE1K,kBAGN,IAAM2N,EAAYF,EAAeG,YAE3BC,EAAoB1V,EAAawV,GAAYjD,EAAErD,gBAAiB,GAEhEyG,EAAwE,IAAhEpD,EAAEnD,WAAamD,EAAEpD,WAAaoD,EAAElD,uBAAyB,IAIjEuG,EAAUf,GACZ,IAAIpW,IAAgB,IAAPkX,EAAW,EAAG,GAC3BA,EACApD,EAAErD,iBAKA2G,EAAY5K,EAAkB2K,GAC9BE,EAAiBlV,EAAc,CAAC8U,EAAmBG,IAEnDE,EAAYjB,GAAiBlW,EAAIG,EAAIwT,EAAGtM,GAExChG,EAAOS,EAAuBoV,EAAgBC,GAE9CC,EAAO1V,EAAqBkV,EAAWvV,GAEzCoK,EAAYD,EAAmB4L,GAEnC,OAAO3L,EAGX,SAAS4L,GAAcrX,EAAIG,EAAIwT,EAAGtM,GAC9B,IAAIkL,EAAM,GAEJgE,EAAc7C,GAAkBC,EAAGtM,GAEnCiQ,EAAOzB,GAAkB7V,EAAkB,GAAduW,EAAkB,EAAKtW,KAAKyH,GAAI,EAAIiM,EAAE1C,cACnEsG,EAAO1B,GAAkB1V,EAAkB,GAAdoW,EAAkB,EAAKtW,KAAKyH,GAAI,EAAIiM,EAAE1C,cAQzE,OANAqG,EAAKE,UACLD,EAAKC,UAELjF,EAAI7R,KAAK4W,GACT/E,EAAI7R,KAAK6W,GAEFhF,EAGJ,SAASC,GAAemB,GAC3B,IAAM3T,EAAK,IAAIH,IAAwB,IAAf8T,EAAEjD,WAAiB,GACrCvQ,EAAK,IAAIN,IAAuB,GAAf8T,EAAEjD,WAAiB,GAE1CiD,EAAEC,kBAAoBD,EAAE5C,aAAe4C,EAAE7C,cAAgB6C,EAAE3C,SAK3D,IAHA,IAAIvF,EAAY,GAEZgM,EAAS,EACAA,EAAS9D,EAAExC,WAAYsG,GAAU9D,EAAErC,YAAa,CAAC,IAAD,gBAExCmF,GAAOzW,EAAIG,EAAIwT,EAAG8D,IAFsB,IAEzD,2BAA4C,CAAC,IAAlC5L,EAAiC,QACxCA,EAAG6L,aAAaD,EAAS9D,EAAEtC,aAC3B5F,EAAU/K,KAAKmL,IAJsC,+BAQ7D,KAAa4L,EAAS9D,EAAEvC,YAAaqG,GAAU9D,EAAErC,YAAa,CAAC,IAAD,gBACzC+F,GAAcrX,EAAIG,EAAIwT,EAAG8D,IADgB,IAC1D,2BAAmD,CAAC,IAAzC5L,EAAwC,QAC/CA,EAAG6L,aAAaD,EAAS9D,EAAEtC,aAC3B5F,EAAU/K,KAAKmL,IAHuC,+BAO9D,OAAOJ,GH9PX,WAGI,IAAK,IAAMmG,KAFXzB,EAAa,GAEKE,EACF,YAARuB,EACAzB,EAAWyB,GAAOvB,EAAmBuB,GAAKpI,QAE1C2G,EAAU,QAAc,CACpBvG,gBAAiByG,EAAmBoB,QAAQ7H,gBAAgBJ,QAC5DG,kBAAmB+H,KAK/BvB,EAAa0B,KAejB8F,G,sCIlCA,SAASC,GAAiBC,EAAYC,GAClCD,EAAWtJ,IACP4B,EACA2H,EACA3H,EAAW2H,GAAkB5X,IAC7BiQ,EAAW2H,GAAkB1X,KAC/B2X,UAAS,SAAUpU,GACjBwM,EAAW2H,GAAoBnU,EAG/B6K,QAIR,SAASwJ,GAAqBH,EAAYI,EAAyBC,GAE/D,IAAMvO,EAAoBD,EAAawO,GAAavO,kBAEpDyI,QAAQC,IAAI6F,GAEZ/H,EAAWsB,QAAQ9H,kBAAkBsO,GAA2BtO,EAAkBsO,GAAyBzO,QAE5FqO,EAAWtJ,IACtB4B,EAAWsB,QAAQ9H,kBACnBsO,EACAtO,EAAkBsO,GAAyB/X,IAC3CyJ,EAAkBsO,GAAyB7X,KAGxC2X,UAAS,SAAUpU,GACtBwM,EAAWsB,QAAQ7H,gBAAkBF,EAAawO,GAAatO,gBAC/DuG,EAAWsB,QAAQ9H,kBAAkBsO,GAA2BtU,EAGhE6K,Q,oBCpBO2J,OAtCf,WACI,IAAMzL,EAAQ0L,iBAAO,MACfC,EAAcD,iBAAO,MACrBE,EAAYF,iBAAO,MAoBzB,OAfAG,qBAAU,WACNnG,QAAQC,IAAI3F,GAEZ,MAA2CgB,EAAMhB,GAAnCE,GAAd,EAAOO,MAAP,EAAcP,QAAQD,EAAtB,EAAsBA,SAAUU,EAAhC,EAAgCA,QAOhC,OALAgL,EAAYxL,QAAUF,EACtB2L,EAAUzL,QAAUD,EDZrB,SAAmBO,GACtB,IAAMqL,EAAM,IAAIC,KAAI,CAAEC,WAAW,EAAMrK,MAAO,MAE9C,IAAK,IAAM6J,KAAexO,EAAc,CACpC,IAAMiP,EAAkBH,EAAII,UAAUV,GAEtC,IAAK,IAAMW,KAAoBnP,EAAawO,GAAavO,kBACrDyI,QAAQC,IAAIwG,GAEZb,GAAqBW,EAAiBE,EAAkBX,GAIhE,IAAMY,EAAoBN,EAAII,UAAU,0BAExC,IAAK,IAAMG,KAAiB5I,EACF,YAAlB4I,GAA+B1I,EAAmB2I,eAAeD,IACjEnB,GAAiBkB,EAAmBC,GCHlCE,GAEC,WACHlJ,EAAQrD,EAAOC,EAAUU,MAE9B,CAACgL,EAAaC,IAGb,eAAC,KAAD,CACIY,QAAM,EACNC,SAAU,WACN1M,EAAOC,EAAO2L,EAAYxL,QAASyL,EAAUzL,UAHrD,SAKK,gBAAEuM,EAAF,EAAEA,WAAF,OACG,sBAAKC,UAAW,YAAaC,IAAKF,EAAlC,SACI,sBAAKC,UAAW,eAAgBC,IAAK5M,EAAO6M,SAAU,UCpB3DC,OAVf,WACI,OACI,sBAAKH,UAAW,MAAhB,SACI,sBAAKA,UAAW,YAAhB,SACI,eAAC,GAAD,SCFDI,GAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,8BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASzM,OACP,eAAC,IAAM0M,WAAP,UACE,eAAC,GAAD,MAEFC,SAASC,eAAe,SAM1BZ,O","file":"static/js/main.5acc646f.chunk.js","sourcesContent":["export const shaders = {\n    normalShader: {\n        vertexShader: `\n            varying vec3 v_Normal;\n            void main() {\n                v_Normal = normal;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            varying vec3 v_Normal;\n            void main() {\n                gl_FragColor = vec4(v_Normal * .8, .8);\n                // vec3 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);\n    \n            }`,\n        transparent: true,\n        uniforms: {}\n    },\n\n    smokeShader: {\n        fragmentShader: `\n            uniform vec2 res;\n            uniform sampler2D bufferTexture;\n            uniform vec3 smokeSource;\n            \n            void main() {\n                vec2 pixel = gl_FragCoord.xy / res.xy;\n                gl_FragColor = texture2D( bufferTexture, pixel );\n            \n                //Get the distance of the current pixel from the smoke source\n                float dist = distance(smokeSource.xy,gl_FragCoord.xy);\n                //Generate smoke when mouse is pressed\n                gl_FragColor.rgb += smokeSource.z * max(15.0-dist,0.0);\n            \n                //Smoke diffuse\n                float xPixel = 1.0/res.x;//The size of a single pixel\n                float yPixel = 1.0/res.y;\n                vec4 rightColor = texture2D(bufferTexture,vec2(pixel.x+xPixel,pixel.y));\n                vec4 leftColor = texture2D(bufferTexture,vec2(pixel.x-xPixel,pixel.y));\n                vec4 upColor = texture2D(bufferTexture,vec2(pixel.x,pixel.y+yPixel));\n                vec4 downColor = texture2D(bufferTexture,vec2(pixel.x,pixel.y-yPixel));\n                //Diffuse equation\n                gl_FragColor.rgb += 14.0 * 0.016 * (leftColor.rgb + rightColor.rgb + downColor.rgb + upColor.rgb - 4.0 * gl_FragColor.rgb);\n            }`\n    },\n\n    gridNormal: {\n        vertexShader: `\n            varying vec3 v_Position;\n            varying vec3 v_Normal;\n            void main() {\n                v_Position = position;\n                v_Normal = normal;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            varying vec3 v_Position;\n            varying vec3 v_Normal;\n            void main() {\n                vec3 grid = abs(fract(v_Position - 0.5) - 0.5) / fwidth(v_Position);\n                float line = min(min(grid.x, grid.y), grid.z);\n                float value = 3.- min(line,3.);\n                float transparency = .1 + value * .9;\n            \n                gl_FragColor = vec4(v_Normal * value, transparency);\n                // vec3 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);\n            }`,\n        transparent: true,\n        uniforms: {},\n        extensions: {derivatives: true}\n    },\n\n    grid: {\n        vertexShader: `\n            varying vec3 v_Position;\n            void main() {\n                v_Position = position;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            varying vec3 v_Position;\n            void main() {\n                vec3 grid = abs(fract(v_Position - .5) - .5) / fwidth(v_Position);\n                float line = min(min(grid.x, grid.y), grid.z);\n                float value = 2.5- min(line, 2.5);\n                float transparency = .1 + value * .9;\n\n                gl_FragColor = vec4(vec3(0.), transparency);\n                // vec3 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);\n            }`,\n        transparent: true,\n        uniforms: {},\n        extensions: {derivatives: true}\n    },\n\n    zGrid: {\n        vertexShader: `\n            varying float z_Position;\n            varying vec3 v_Normal;\n            void main() {\n                z_Position = position.z;\n                v_Normal = normal;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            varying float z_Position;\n            varying vec3 v_Normal;\n            void main() {\n                float line = abs(fract(z_Position - 0.5) - 0.5) / fwidth(z_Position);\n                float value = 3.- min(line,3.);\n                float transparency = .1 + value * .9;\n    \n                gl_FragColor = vec4(v_Normal * value, transparency);\n                // vec3 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);\n            }`,\n        transparent: true,\n        uniforms: {},\n        extensions: {derivatives: true}\n    },\n\n    edges: {\n        vertexShader: `\n            attribute vec2 barycentric;\n            varying vec2 b;\n            void main () {\n                b = barycentric;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            // float gridFactor (vec2 vBC, float width, float feather) {\n            //     float w1 = width - feather * 0.5;\n            //     vec3 bary = vec3(vBC.x, vBC.y, 1.0 - vBC.x - vBC.y);\n            //     vec3 d = fwidth(bary);\n            //     vec3 a3 = smoothstep(d * w1, d * (w1 + feather), bary);\n            //    \n            //     return min(min(a3.x, a3.y), a3.z);\n            // }\n            \n            float gridFactor (vec2 vBC, float width) {\n                vec3 bary = vec3(vBC.x, vBC.y, 1.0 - vBC.x - vBC.y);\n                vec3 d = fwidth(bary);\n                vec3 a3 = smoothstep(d * (width - 0.5), d * (width + 0.5), bary);\n                \n                return min(min(a3.x, a3.y), a3.z);\n            }\n            \n            varying vec2 b;\n            \n            void main () {\n                gl_FragColor = vec4(vec3(gridFactor(b, 1.0) * .6), 1);\n            }`,\n        transparent: true,\n        extensions: {derivatives: true}\n    }\n}\n","import {DelaunayTriangulationBuilder} from \"jsts/org/locationtech/jts/triangulate\";\nimport {WKTReader} from \"jsts/org/locationtech/jts/io\";\nimport BufferOp from \"jsts/org/locationtech/jts/operation/buffer/BufferOp\";\nimport {Geometry, GeometryCollection, GeometryFactory} from \"jsts/org/locationtech/jts/geom\";\nimport \"jsts/org/locationtech/jts/monkey.js\";\nimport {BufferAttribute, BufferGeometry, LineCurve, Vector3} from \"three\";\nimport {CustomLine} from \"./test-geo\";\nimport {UnaryUnionOp} from \"jsts/org/locationtech/jts/operation/union\";\n\nfunction triangulationFromPolygon(polygon) {\n    const builder = new DelaunayTriangulationBuilder();\n\n    builder.setSites(polygon);\n    builder.setTolerance(.01);\n\n    let triangulation = builder.getTriangles(new GeometryFactory());\n\n    // console.log(triangulation);\n\n    return triangulation;\n}\n\nfunction polygonToBufferGeometry(polygon) {\n    const triangulation = triangulationFromPolygon(polygon);\n    return bufferFromTriangulation(triangulation);\n}\n\nfunction edgesFromTriangulation(triangulation) {\n    let vertexDict = {};\n    let vPairs = {};\n    let pureVertices = {};\n\n    for (const boundary in triangulation._geometries) {\n        const bnd = triangulation.getGeometryN(boundary);\n        const coords = bnd.getCoordinates();\n\n        if (coords.length === 4) {\n            let cMap = [0, 0, 0];\n            for (const idx in [0,1,2]) {\n                const coor = coords[idx];\n\n                let coordinate = JSON.stringify({x: coor.x, y: coor.y, z: .1});\n\n                const dictCount = Object.keys(vertexDict).length;\n\n                if (!(coordinate in vertexDict)) {\n                    // console.log(coordinate);\n\n                    vertexDict[coordinate] = dictCount;\n                    pureVertices[coordinate] = new Vector3(coor.x, coor.y, .1);\n                    cMap[idx] = dictCount;\n                } else {\n                    cMap[idx] = vertexDict[coordinate];\n                }\n            }\n\n            // console.log(cMap);\n\n            for (const idx in [0,1,2]) {\n                let a = cMap[idx];\n                let b = cMap[(idx + 1) % 3];\n\n                let v0 = Math.min(a, b);\n                let v1 = Math.max(a, b);\n\n                vPairs[JSON.stringify([v0, v1])] = [v0, v1];\n            }\n        }\n    }\n\n    let idxVertex = {};\n    for(const v in vertexDict){\n        const idx = vertexDict[v];\n        idxVertex[idx] = pureVertices[v];\n    }\n\n    let lines = [];\n\n    for (const idx in vPairs) {\n        // console.log(vPairs[idx]);\n\n        const a = vPairs[idx][0];\n        const b = vPairs[idx][1];\n\n        // console.log(vPairs);\n        // console.log(a, b);\n        // console.log(idxVertex[a], idxVertex[b]);\n\n        const localLineCurve = new LineCurve(idxVertex[a], idxVertex[b]);\n\n        // localLineCurve.arcLengthDivisions = 1;\n\n        lines.push(localLineCurve);\n    }\n\n    return lines;\n}\n\nfunction bufferFromTriangulation(triangulation) {\n    // let geoCollection = new GeometryCollection();\n\n    let bufferGeo = new BufferGeometry();\n    let coordinatesList = [];\n\n    for (const boundary in triangulation._geometries) {\n        const bnd = triangulation.getGeometryN(boundary);\n        const coords = bnd.getCoordinates();\n\n        if (coords.length === 4) {\n            for (const idx in [0,1,2]) {\n                const coor = coords[idx];\n                coordinatesList.push(coor.x);\n                coordinatesList.push(coor.y);\n                coordinatesList.push(.1);\n            }\n        }\n    }\n\n    const vertices = new Float32Array( coordinatesList );\n\n    bufferGeo.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n    bufferGeo.computeVertexNormals();\n\n    return bufferGeo;\n}\n\nexport function createBuffer(geom, radius, segments = 32) {\n    return BufferOp.bufferOp(geom, radius, segments);\n}\n\nexport function displayPoint(aString) {\n    let reader = new WKTReader();\n\n    let pt = reader.read(aString);\n\n    let buffered = createBuffer(pt, 20);\n\n    const triangulation = triangulationFromPolygon(buffered);\n\n    return {\n        buffer: bufferFromTriangulation(triangulation),\n        edges: edgesFromTriangulation(triangulation)\n    };\n}\n\nexport function geometriesUnion(geos) {\n    if (geos.length === 1){\n        return geos[0];\n    }\n\n    const geoFac = new GeometryFactory();\n    const geoCollection = geoFac.createGeometryCollection(geos).union();\n\n    return geoCollection;\n}\n\nexport function geometriesDifference(geosA, geosB) {\n    return geosA.difference(geosB);\n}\n\nexport function geometriesIntersection(geosA, geosB) {\n    return geosA.intersection(geosB);\n}\n\nexport function readWKString(strings) {\n    const reader = new WKTReader();\n    const geos = [];\n\n    for (const aString of strings) {\n        geos.push(reader.read(aString));\n    }\n\n    return geos;\n}\n\nexport function geometryUnion(geos) {\n    const collection = geometriesUnion(geos);\n\n    return UnaryUnionOp.union(collection);\n}\n\nexport function multiplePoints(){\n    const strings = [\n        'POINT (-20 0)',\n        'POINT (20 0)',\n        'POINT (0 15)'\n    ];\n\n    const geos = readWKString(strings);\n    let bufferedGeos = [];\n\n    for (const geo of geos) {\n        bufferedGeos.push(BufferOp.bufferOp(geo, 30, 100));\n    }\n\n    const geom = geometryUnion(bufferedGeos);\n\n    return geom;\n}\n\nexport function triangulatePolyline(plg) {\n    const triangulation = triangulationFromPolygon(plg);\n\n    return {\n        buffer: bufferFromTriangulation(triangulation),\n        edges: edgesFromTriangulation(triangulation)\n    };\n}\n\nexport function testPolygon() {\n    // let reader = new WKTReader();\n    //\n    // const pt = reader.read('POINT (0 0)');\n    // const buffer = BufferOp.bufferOp(pt, 30)\n\n    return multiplePoints();\n}\n\nexport function displayPointTest(){\n    return triangulatePolyline(multiplePoints());\n}\n","import {Vector3} from \"three\";\nimport {Coordinate} from \"jsts/org/locationtech/jts/geom\";\n\nexport class ClayPoint {\n    origin;\n    direction;\n    position;\n    uvValue;\n\n    constructor(origin, direction) {\n        this.origin = origin;\n        this.position = new Vector3().copy(origin);\n        this.direction = direction;\n    }\n\n    move(value) {\n        this.position = new Vector3().addVectors(\n            this.position,\n            new Vector3().addScaledVector(this.direction, value)\n        );\n    }\n\n    set(value) {\n        this.position = new Vector3().addVectors(\n            this.origin,\n            new Vector3().addScaledVector(this.direction, value)\n        );\n    }\n\n    toCoordinate() {\n        return new Coordinate(\n            this.position.x,\n            this.position.y,\n            this.position.z\n        )\n    }\n\n    toVector3() {\n        return new Vector3(this.position.x, this.position.z, -this.position.y);\n    }\n}\n\nexport function clayPointTest() {\n    const vBase = new Vector3(0, 0, 0);\n    const vDir = new Vector3(1, 0, 0);\n\n    const clayPoint = new ClayPoint(vBase, vDir);\n\n    clayPoint.move(1.);\n\n    clayPoint.set(10.);\n}\n","import {Curve, Matrix4, Vector3} from \"three\";\nimport {clamp} from \"three/src/math/MathUtils\";\n\nexport class CustomSinCurve extends Curve {\n\n    constructor( scale = 1 ) {\n\n        super();\n\n        this.scale = scale;\n\n    }\n\n    getPoint( t, optionalTarget = new Vector3() ) {\n\n        const tx = t * 3 - 1.5;\n        const ty = Math.sin( 2 * Math.PI * t );\n        const tz = 0;\n\n        return optionalTarget.set( tx, ty, tz ).multiplyScalar( this.scale );\n    }\n}\n\nexport class CustomLine extends Curve {\n\n    constructor(v0, v1) {\n        super();\n\n        this.v0 = v0;\n        this.vDir = v1 - this.v0;\n\n        this.scale = 1.;\n    }\n\n    getPoint(t, optionalTarget = new Vector3()) {\n        const v = this.v0 + t * this.vDir;\n        // console.log(v);\n\n        return optionalTarget.set(v.x, v.y, v.z).multiplyScalar( this.scale );\n    }\n}\n\nexport class Polyline extends Curve {\n    constructor(points, closed = true) {\n        super();\n\n        this.points = points;\n        this.closed = closed;\n\n        this.init();\n    }\n\n    init() {\n        this.dirs = this.getDirs();\n\n        this.arcLengthDivisions = this.getPointCount();\n    }\n\n    getPointCount() {\n        if (this.closed) {\n            return this.points.length;\n        } else {\n            return this.points.length - 1;\n        }\n    }\n\n    getDirs() {\n        let dirList = [];\n\n        for (let i = 0; i < this.getPointCount(); i++) {\n            const v0 = this.points[i];\n            const v1 = this.points[(i+1) % this.getPointCount()];\n\n            const vDir = new Vector3().subVectors(v1, v0);\n\n            dirList.push(vDir);\n        }\n\n        return dirList;\n    }\n\n    getLength() {\n        const lengths = this.getLengths();\n        return lengths[lengths.length - 1];\n    }\n\n    getLengths() {\n        if ( this.cacheArcLengths &&\n            ( this.cacheArcLengths.length === this.getPointCount() + 1 ) &&\n            ! this.needsUpdate ) {\n\n            return this.cacheArcLengths;\n        }\n\n        let previous = 0.;\n        this.cacheArcLengths = [previous];\n\n        for (const dir of this.dirs) {\n            previous += dir.length();\n            this.cacheArcLengths.push(previous);\n        }\n\n        return this.cacheArcLengths;\n    }\n\n    getTangentAt(u, optionalTarget = new Vector3()) {\n        return this.getTangent(u * this.getPointCount(), optionalTarget)\n    }\n\n    getTangent(t, optionalTarget = new Vector3()) {\n        const locT = t % 1.;\n        let roundT = t - t % 1.;\n\n        if (isNaN(t)) {\n            return null;\n        }\n\n        let vT;\n\n        if (t > 0 && t < this.getPointCount()) {\n            if ( locT < .0001 ) {\n                const v1 = new Vector3().copy(this.dirs[roundT]);\n                const v0 = new Vector3().copy(this.dirs[roundT - 1]);\n\n                v0.normalize();\n                v1.normalize();\n\n                vT = new Vector3().addVectors(v0, v1);\n            } else {\n                vT = new Vector3().copy(this.dirs[roundT]);\n            }\n        }\n\n        if (this.closed) {\n            roundT %= this.getPointCount();\n\n            if ( locT < .0001 ) {\n                const v1 = new Vector3().copy(this.dirs[roundT]);\n                const v0 = new Vector3().copy(this.dirs[(roundT + this.getPointCount() - 1) % this.getPointCount()]);\n\n                v0.normalize();\n                v1.normalize();\n\n                vT = new Vector3().addVectors(v0, v1);\n            } else {\n                vT = new Vector3().copy(this.dirs[roundT]);\n            }\n        } else {\n            if (t < 1) {\n                vT = new Vector3().copy(this.dirs[0]);\n            } else {\n                vT = new Vector3().copy(this.dirs[this.dirs.length - 1]);\n            }\n        }\n\n        vT.normalize();\n        return optionalTarget.set(vT.x, vT.y, vT.z);\n    }\n\n    computeFrenetFrames( segments, closed ) {\n\n        // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n        const normal = new Vector3();\n\n        const tangents = [];\n        const normals = [];\n        const binormals = [];\n\n        const vec = new Vector3();\n        const mat = new Matrix4();\n\n        // compute the tangent vectors for each segment on the curve\n\n        for ( let i = 0; i <= segments; i ++ ) {\n\n            const u = i / segments;\n\n            tangents[ i ] = this.getTangentAt( u, new Vector3() );\n\n        }\n\n        // select an initial normal vector perpendicular to the first tangent vector,\n        // and in the direction of the minimum tangent xyz component\n\n        normals[ 0 ] = new Vector3();\n        binormals[ 0 ] = new Vector3();\n        let min = Number.MAX_VALUE;\n        const tx = Math.abs( tangents[ 0 ].x );\n        const ty = Math.abs( tangents[ 0 ].y );\n        const tz = Math.abs( tangents[ 0 ].z );\n\n        if ( tx <= min ) {\n\n            min = tx;\n            normal.set( 1, 0, 0 );\n\n        }\n\n        if ( ty <= min ) {\n\n            min = ty;\n            normal.set( 0, 1, 0 );\n\n        }\n\n        if ( tz <= min ) {\n\n            normal.set( 0, 0, 1 );\n\n        }\n\n        vec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n        normals[ 0 ].crossVectors( tangents[ 0 ], vec );\n        binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n        // compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n        for ( let i = 1; i <= segments; i ++ ) {\n\n            normals[ i ] = normals[ i - 1 ].clone();\n\n            binormals[ i ] = binormals[ i - 1 ].clone();\n\n            vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n            if ( vec.length() > Number.EPSILON ) {\n\n                vec.normalize();\n\n                const theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n                normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n            }\n\n            binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n        }\n\n        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n        if ( closed === true ) {\n\n            let theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n            theta /= segments;\n\n            if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n                theta = - theta;\n\n            }\n\n            for ( let i = 1; i <= segments; i ++ ) {\n\n                // twist a little...\n                normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n                binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n            }\n\n        }\n\n        // console.log({\n        //     tangents: tangents,\n        //     normals: normals,\n        //     binormals: binormals\n        // });\n\n        return {\n            tangents: tangents,\n            normals: normals,\n            binormals: binormals\n        };\n\n    }\n\n    _tConstraining(t) {\n        let locT = t % 1.;\n\n        let t0 = t - locT;\n\n        if (this.closed) {\n            t0 %= this.getPointCount();\n        } else {\n            if (t0 < 0) {\n                locT += t0;\n                t0 = 0;\n            } else if (t0 >= this.getPointCount()) {\n                locT += t0 - this.getPointCount();\n                t0 = this.getPointCount();\n            }\n        }\n\n        return {\n            locT: locT,\n            t0: t0\n        };\n    }\n\n    getPointAt(t, optionalTarget = new Vector3() ) {\n        return this.getPoint(t, optionalTarget);\n    }\n\n    getPoint( t, optionalTarget = new Vector3() ) {\n        t *= this.getPointCount();\n\n        const {locT, t0} = this._tConstraining(t);\n\n        const v0 = this.points[t0];\n        const vDir = this.dirs[t0];\n\n        const v = new Vector3().addVectors(v0, new Vector3().addScaledVector(vDir, locT));\n\n        return optionalTarget.set(v.x, v.y, v.z);\n    }\n\n    moveToHeight(height = 0.){\n        for (const point of this.points) {\n            point.y = height;\n        }\n    }\n\n    makeMeWave(periods = 2., amplitude = 5.) {\n        const step = (periods * 2. * Math.PI) / this.getPointCount();\n        let phase = 0.;\n\n        for (let i = 0; i < this.getPointCount(); i++ ) {\n            this.points[i].z += amplitude * Math.sin(phase);\n            phase += step;\n        }\n\n        this.init();\n    }\n\n    cadFlip() {\n        for (const pt of this.points) {\n            pt.set(pt.x, pt.z, -pt.y);\n        }\n    }\n}","export function sinWaveUVPattern(uv, parameters) {\n    const phase = parameters.phaseDelta * uv.y;\n    return Math.sin(uv.x * Math.PI / parameters.period + phase) * parameters.amplitude + parameters.offset;\n}\n\n// function that gives the distance to the closest point in the UV grid\nfunction dotForUV(uv, parameters) {\n    let localU, localV;\n\n    localU = (uv.x - parameters.baseU % parameters.uSpacing) % parameters.uSpacing - parameters.uSpacing * .5;\n    localV = (uv.y - parameters.baseV % parameters.vSpacing) % parameters.vSpacing - parameters.vSpacing * .5;\n\n    if (parameters.positionShift) {\n        if ( (Math.abs(localU) / parameters.uSpacing + Math.abs(localV) / parameters.vSpacing ) > .5 ) {\n            if (localU < 0.) {\n                localU = -parameters.uSpacing * .5 - localU;\n            } else {\n                localU = parameters.uSpacing * .5 - localU;\n            }\n            if (localV < 0.) {\n                localV = -parameters.vSpacing * .5 - localV;\n            } else {\n                localV = parameters.vSpacing * .5 - localV;\n            }\n        }\n    }\n\n    return {\n        localU: localU,\n        localV: localV\n    }\n}\n\nfunction dotCylinderForUV(uv, parameters) {\n    let localU, localV;\n\n    localU = (uv.x - parameters.baseU % parameters.uSpacing) % parameters.uSpacing;\n    localV = (uv.y - parameters.baseV % parameters.vSpacing) % parameters.vSpacing - parameters.vSpacing * .5;\n\n    if (parameters.positionShift){\n        if (Math.round((uv.y - localV) / parameters.vSpacing) % 2. === 1.) {\n            localU += parameters.uSpacing * .5;\n            localU %= parameters.uSpacing;\n        }\n    }\n\n    localU -= parameters.uSpacing * .5;\n\n    return {\n        localU: localU,\n        localV: localV\n    }\n}\n\nfunction unitRadiusForDot(uv, parameters) {\n    let {localU, localV} = dotForUV(uv, parameters);\n\n    localV *= parameters.radiusScaleV;\n\n    const localDistance = Math.sqrt(localU * localU + localV * localV);\n\n    if (localDistance > parameters.radius) {\n        return 0.;\n    } else {\n        return 1. - localDistance / parameters.radius;\n    }\n}\n\nexport function dotPyramidUVPattern(uv, parameters) {\n    const locRadius = unitRadiusForDot(uv, parameters);\n    return locRadius * parameters.amplitude;\n}\n\nexport function dotEllipsoidUVPattern(uv, parameters) {\n    const locRadius = unitRadiusForDot(uv, parameters);\n    return Math.sqrt(1. - (1. - locRadius) ** 2) * parameters.amplitude;\n}\n\nexport function dotInverseUVPattern(uv, parameters) {\n    const locRadius = unitRadiusForDot(uv, parameters);\n    return (1. - Math.sqrt(1. - locRadius ** 2)) * parameters.amplitude;\n}\n\nexport function edgeUVConstraining(uv, easingParameters) {\n    const length = uv.x;\n    if (length >= easingParameters.endLength | length <= easingParameters.startLength){\n        return 0.;\n    } else if (length >= easingParameters.startMaxLength & length <= easingParameters.endMaxLength){\n        return 1.;\n    } else if (length < easingParameters.startMaxLength) {\n        return (length - easingParameters.startLength) * easingParameters.easingDelta;\n    } else if (length > easingParameters.endMaxLength) {\n        return 1. - (length - easingParameters.endMaxLength) * easingParameters.easingDelta;\n    } else {\n        return null;\n    }\n}\n\nexport function cylinderUVFunction(uv, parameters) {\n    let {localU, localV} = dotCylinderForUV(uv, parameters);\n\n    const rD = parameters.radiusB - parameters.radiusA;\n\n    localU = Math.abs(localU);\n    let localR;\n\n    if (Math.abs(localV) + 0.001 < parameters.height * .5) {\n        localR = parameters.radiusA + rD * (localV / parameters.height + .5);\n    } else {\n        localR = -1.;\n    }\n\n    if (localU > localR) {\n        return 0.;\n    } else {\n        return (1 - (localU / localR) ** 2.) ** .5 * parameters.amplitude;\n    }\n}\n\nexport const DEFAULT_SIN_WAVE_UV_PARAMETERS = {\n    amplitude: {default: 2., min: 0., max: 10.},\n    period: {default: 30., min: 10., max: 500.},\n    phaseDelta: {default: 1., min: -10., max: 10.},\n    offset: {default: 0., min: -10., max: 10.},\n    uv: {default: 1, min: 0, max: 1}\n};\n\nexport const DEFAULT_UV_DOT_PARAMETERS = {\n    baseU: {default: 0., min: -100., max: 100.},\n    baseV: {default: 0., min: -100., max: 100.},\n    amplitude: {default: 10., min: -20., max: 20.},\n    uSpacing: {default: 50., min: 0., max: 100.},\n    vSpacing: {default: 50., min: 0., max: 100.},\n    radius: {default: 25., min: 2., max: 50.},\n    radiusScaleV: {default: 1., min: 0., max: 10.},\n    positionShift: {default: 0., min: 0, max: .5},\n    uv: {default: 1, min: 0, max: 1}\n}\n\nexport const DEFAULT_CYLINDER_UV_PARAMETERS = {\n    baseU: {default: 0., min: -100., max: 100.},\n    baseV: {default: 0., min: -100., max: 100.},\n    amplitude: {default: 10., min: -20., max: 20.},\n    height: {default: 30., min: 5., max: 100.},\n    uSpacing: {default: 50., min: 0., max: 100.},\n    vSpacing: {default: 50., min: 0., max: 100.},\n    radiusA: {default: 7.5, min: 2., max: 50.},\n    radiusB: {default: 15., min: 2., max: 50.},\n    positionShift: {default: 0., min: 0, max: .5},\n    uv: {default: 1, min: 0, max: 1}\n}\n\nexport const PATTERN_LIST = {\n    sinWaveUVPattern: {\n        patternParameters: DEFAULT_SIN_WAVE_UV_PARAMETERS,\n        patternFunction: sinWaveUVPattern\n    },\n    dotPyramidUVPattern: {\n        patternParameters: DEFAULT_UV_DOT_PARAMETERS,\n        patternFunction: dotPyramidUVPattern\n    },\n    dotEllipsoidUVPattern: {\n        patternParameters: DEFAULT_UV_DOT_PARAMETERS,\n        patternFunction: dotEllipsoidUVPattern\n    },\n    dotInverseUVPattern: {\n        patternParameters: DEFAULT_UV_DOT_PARAMETERS,\n        patternFunction: dotInverseUVPattern\n    },\n    cylinderUVFunction: {\n        patternParameters: DEFAULT_CYLINDER_UV_PARAMETERS,\n        patternFunction: cylinderUVFunction\n    }\n}\n","import {GeometryFactory} from \"jsts/org/locationtech/jts/geom\";\nimport {ClayPoint} from './clay-point';\nimport {Vector3} from \"three\";\nimport {Polyline} from \"../three/three-poly-line\";\nimport {edgeUVConstraining} from \"./clay-patterns\";\n\nexport class ClayPatternCurve {\n    clayPoints;\n\n    constructor(clayPoints) {\n        this.clayPoints = clayPoints;\n    }\n\n    toPolygon() {\n        let coordinates =[];\n\n        for (const pt of this.clayPoints) {\n            coordinates.push(pt.toCoordinate());\n        }\n\n        coordinates.push(coordinates[0]);\n\n        return new GeometryFactory().createPolygon(coordinates);\n    }\n\n    toPolyline() {\n        let positions = [];\n\n        for (const pt of this.clayPoints) {\n            positions.push(pt.toVector3());\n        }\n\n        return new Polyline(positions);\n    }\n\n    moveToHeight(height = 0.) {\n        for (const pt of this.clayPoints) {\n            pt.z = height;\n        }\n    }\n\n    applyPattern(patternFunction, parameters, easingParameters = null) {\n        if (parameters.uv) {\n            for (const pt of this.clayPoints) {\n                if (easingParameters) {\n                    const edgeValue = edgeUVConstraining(pt.uvValue, easingParameters);\n                    if (edgeValue !== 0.){\n                        pt.set(patternFunction(pt.uvValue, parameters) * edgeValue);\n                    }\n                } else {\n                    pt.set(patternFunction(pt.uvValue, parameters));\n                }\n            }\n        } else {\n            for (const pt of this.clayPoints) {\n                pt.set(patternFunction(pt.origin, parameters));\n            }\n        }\n    }\n\n    toThreePolyline() {\n        let positions = [];\n\n        for (const pt of this.clayPoints) {\n            positions.push(pt.toVector3());\n        }\n\n        return new Polyline(positions);\n    }\n}\n\nexport function testClayCurve(scene = null) {\n    let pts = [\n        new ClayPoint(\n            new Vector3(.5, .5, 0),\n            new Vector3(1, 1, 0),\n        ),\n        new ClayPoint(\n            new Vector3(-.5, .5, 0),\n            new Vector3(-1, 1, 0),\n        ),\n        new ClayPoint(\n            new Vector3(-.5, -.5, 0),\n            new Vector3(-1, -1, 0),\n        ),\n        new ClayPoint(\n            new Vector3(.5, -.5, 0),\n            new Vector3(1, -1, 0),\n        ),\n    ];\n\n    const clayCurve = new ClayPatternCurve(pts);\n\n    if (scene) {\n        // console.log(\"is not null?\");\n        // console.log(scene);\n\n\n\n    } else {\n        console.log(\"is null !!!\");\n    }\n}\n","import {GeometryFactory} from \"jsts/org/locationtech/jts/geom\";\nimport {Path, Vector3} from \"three\";\nimport {Polyline} from \"../three/three-poly-line\";\nimport {testPolygon} from \"../importing-jsts\";\n\nconst llr = new GeometryFactory().createLinearRing();\n\nfunction getLinearRings(polygon) {\n    let linearRings = [];\n    linearRings.push(polygon.getExteriorRing());\n\n    // console.log(polygon);\n\n    for (let i = 0; i < polygon.getNumInteriorRing(); i++) {\n        linearRings.push(polygon.getInteriorRingN(i));\n    }\n\n    return linearRings;\n}\n\nfunction vectorFromCoordinate(coordinate) {\n    let locZ;\n\n    if (isNaN(coordinate.z)) {\n        locZ = 0;\n    } else {\n        locZ = coordinate.z;\n    }\n\n    return new Vector3(\n        coordinate.x,\n        locZ,\n        -coordinate.y\n    );\n}\n\nfunction linearRingToPolyline(linearRing) {\n    let vectors = [];\n\n    for (const coordinate of linearRing.getCoordinates()) {\n        vectors.push(vectorFromCoordinate(coordinate) );\n    }\n\n    vectors.pop();\n\n    return new Polyline(vectors);\n}\n\nexport function polygonToPolylines(polygon){\n    let polylines = [];\n\n    if (polygon.constructor.name === \"MultiPolygon\") {\n        for (const pg of polygon._geometries) {\n            for (const pl of polygonToPolylines(pg)){\n                polylines.push(pl);\n            }\n        }\n\n        return polylines;\n    }\n\n    const lrs = getLinearRings(polygon);\n\n    for (const lr of lrs){\n        polylines.push(linearRingToPolyline(lr));\n    }\n\n    return polylines;\n}\n","import {GeometryFactory} from \"jsts/org/locationtech/jts/geom\";\nimport Coordinate from \"jsts/org/locationtech/jts/geom/Coordinate\";\n\nfunction vector3toCoordinate(vector3) {\n    return new Coordinate(vector3.x, vector3.y, vector3.z);\n}\n\nfunction coordinatesFromPolyline(polyline) {\n    let coordinates = [];\n\n    for (const pt of polyline.points) {\n        coordinates.push(vector3toCoordinate(pt));\n    }\n\n    coordinates.push(coordinates[0]);\n\n    return coordinates;\n}\n\nexport function polylineToPolygon(polyline) {\n    const geoFactory = new GeometryFactory();\n\n    let coordinates = [];\n\n    const polygon = geoFactory.createPolygon(coordinatesFromPolyline(polyline));\n\n    return polygon;\n};","import {PCFShadowMap, WebGL1Renderer, WebGLRenderer} from 'three'\nimport {createHUD} from \"../geometry/three/brick-to-scene\";\n\nexport function getPlanarRenderer() {\n    const renderer = new WebGLRenderer({antialias: true});\n\n    renderer.setClearColor('#cdd0d6');\n    renderer.setPixelRatio(window.devicePixelRatio);\n\n    return renderer;\n}\n\nexport function getPerspectiveRenderer() {\n    const renderer = new WebGL1Renderer({antialias: true, alpha: true})\n\n    // renderer.setClearColor('#ffff99');\n    renderer.setPixelRatio(window.devicePixelRatio);\n\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = PCFShadowMap;\n\n    return renderer;\n}\n\nexport function resize(mount, renderer, camera) {\n    if (!mount || !renderer || !camera)\n        return\n\n    const {clientWidth, clientHeight} = mount.current\n\n    if (camera) {\n        camera.aspect = clientWidth / clientHeight;\n        camera.updateProjectionMatrix();\n    }\n\n    renderer.setSize(clientWidth, clientHeight)\n}\n","import {Scene} from 'three';\nimport {getPerspectiveRenderer, resize} from \"./renderers\";\nimport {getOrbitControls} from \"./orbit-controls\";\nimport {getPerspectiveCamera} from \"./cameras\";\nimport {start, stop} from \"./render-loops\";\nimport {addTestGeos, testTube} from \"../geometry/test-geo\";\nimport {displayPointTest} from \"../geometry/importing-jsts\";\nimport {addBrick, addLighting, updateEasingSettings} from \"../geometry/three/brick-to-scene\";\n\nexport let scene;\nexport let renderer;\n\nexport function setUp(mount) {\n    scene = new Scene();\n\n    const light = addLighting();\n    scene.add(light);\n\n    addBrick();\n\n    displayPointTest();\n\n    renderer = getPerspectiveRenderer();\n    mount.current.appendChild(renderer.domElement);\n\n    // createHUD(light).render(renderer);\n\n    const camera = getPerspectiveCamera(mount.current);\n    scene.add(camera);\n\n    const orbitControls = getOrbitControls(camera, renderer);\n\n    resize(mount, renderer, camera);\n    const frameId = start(renderer, scene, camera);\n\n    return {\n        scene: scene,\n        renderer: renderer,\n        camera: camera,\n        frameId: frameId,\n        orbitControls: orbitControls\n    };\n}\n\nexport function cleanUp(mount, renderer, frameId) {\n    stop(frameId.frameId);\n    mount.current.removeChild(renderer.domElement);\n}\n","export function start(renderer, scene, camera) {\n\n    const frameId = {frameId: null};\n\n    frameId.frameId = requestAnimationFrame(() => animate(renderer, scene, camera, frameId));\n\n    return frameId;\n}\n\nexport function stop({frameId}) {\n    return cancelAnimationFrame(frameId);\n}\n\nfunction animate(renderer, scene, camera, frameId) {\n    renderer.clear('#ddd');\n    renderer.render(scene, camera);\n\n    frameId.frameId = requestAnimationFrame(() => animate(renderer, scene, camera, frameId));\n}\n","import {constructBrick} from \"../clayBrick/clay-simple-base\";\nimport {TubeGeo} from \"../to-three\";\nimport {shaderNormal} from \"../test-geo\";\nimport {DEFAULT_SIN_WAVE_UV_PARAMETERS, sinWaveUVPattern} from \"../clayBrick/clay-patterns\";\nimport {MeshLambertMaterial, TextureLoader, TubeGeometry, Mesh, DirectionalLight} from \"three\";\nimport {scene, renderer} from \"../../three-setup/set-up\";\n\nconst CLAY_TEXTURE_URL = \"https://i.ibb.co/9nk0c8H/terra-cotta-stucco-wall-texture.jpg\";\n\nexport let geometryArray = [];\nexport let overwrites;\n\nexport const OVERWRITE_SETTINGS = {\n    productionWidth: {default: 2.5, min: 1., max: 10.},\n    baseWidth: {default: 150.0, min: 100., max: 200.},\n    baseLength: {default: 300.0, min: 200., max: 400.},\n    lengthBufferMultiplier: {default: 2.0, min: 1.0, max: 10.},\n    pinSpacing: {default: 220.0, min: 100., max: 300.},\n    diamondWidth: {default: 50.0, min: 20., max: 100.},\n    diamondHeight: {default: 110.0, min: 20., max: 200.},\n    diamondCount: {default: 3, min: 1, max: 5},\n    pinDiameter0: {default: 40.0, min: 30., max: 100.},\n    pinDiameter1: {default: 20.0, min: 30., max: 100.},\n    pinDelta: {default: 250.0, min: 1.0, max: 10.},\n    pinDivisions: {default: 60, min: 1.0, max: 10.},\n    precision: {default: 2.0, min: 1.0, max: 10.},\n    bodyHeight: {default: 160.0, min: 1.0, max: 10.},\n    totalHeight: {default: 260.0, min: 1.0, max: 10.},\n    startHeight: {default: -100.0, min: 1.0, max: 10.},\n    layerHeight: {default: 2.5, min: 1.0, max: 10.},\n    easingStart: {default: 20., min: 0., max: 250.},\n    easingEnd: {default: 100., min: 0., max: 250.},\n    pattern: {\n        patternFunction: {default: sinWaveUVPattern},\n        patternParameters: {default: DEFAULT_SIN_WAVE_UV_PARAMETERS}\n    }\n}\n\nfunction overwriteClone() {\n    overwrites = {};\n\n    for (const key in OVERWRITE_SETTINGS) {\n        if (key !== \"pattern\") {\n            overwrites[key] = OVERWRITE_SETTINGS[key].default;\n        } else {\n            overwrites[\"pattern\"] = {\n                patternFunction: OVERWRITE_SETTINGS.pattern.patternFunction.default,\n                patternParameters: patternClone()\n            };\n        }\n    }\n\n    overwrites = updateEasingSettings();\n\n    return overwrites;\n}\n\nfunction patternClone() {\n    let patternSettingsClone = {};\n\n    for (const key in OVERWRITE_SETTINGS.pattern.patternParameters.default) {\n        patternSettingsClone[key] = OVERWRITE_SETTINGS.pattern.patternParameters.default[key].default;\n    }\n\n    return patternSettingsClone;\n}\n\noverwriteClone();\n\nfunction applyBrickShader(scene, pls, parameters) {\n    const loader = new TextureLoader();\n\n    const pipeRadius = parameters.layerHeight * .6;\n\n    loader.load(\n        // resource URL\n        CLAY_TEXTURE_URL,\n\n        // onLoad callback\n        function ( texture ) {\n            // in this example we create the material when the texture is loaded\n            const brickShader = new MeshLambertMaterial( {\n                map: texture\n            } );\n\n            // const brickShader = shaderNormal();\n\n            for (const pl of pls) {\n                const tubeGeo = new TubeGeometry(pl, pl.getPointCount(), pipeRadius, 6, true);\n                const locMesh = new Mesh(tubeGeo, brickShader);\n\n                locMesh.castShadow = true;\n                locMesh.receiveShadow = true;\n\n                geometryArray.push(locMesh);\n\n                scene.add(locMesh);\n            }\n        },\n\n        // onProgress callback currently not supported\n        undefined,\n\n        // onError callback\n        function ( err ) {\n            console.error( 'An error happened.' );\n        }\n    );\n}\n\nexport function addLighting() {\n    const directionalLight = new DirectionalLight( 0xffffff, 1.1 );\n    directionalLight.position.set(500,500,500);\n\n    directionalLight.castShadow = true;\n    directionalLight.shadow.camera.near = 1200;\n    directionalLight.shadow.camera.far = 2500;\n    directionalLight.shadow.bias = 0.0001;\n\n    directionalLight.shadow.mapSize.width = 4096;\n    directionalLight.shadow.mapSize.height = 4096;\n\n    return directionalLight;\n}\n\nfunction totalLength() {\n    return overwrites.baseWidth * Math.PI + (overwrites.baseLength - overwrites.baseWidth) * 2.;\n}\n\nexport function updateEasingSettings() {\n    const locTotalLength = totalLength();\n\n    overwrites.easingParameters = {\n        startLength: overwrites.easingStart,\n        startMaxLength: overwrites.easingEnd,\n        endMaxLength: locTotalLength * .5 - overwrites.easingEnd,\n        endLength: locTotalLength * .5 - overwrites.easingStart,\n        easingDelta: 1. / (overwrites.easingEnd - overwrites.easingStart)\n    };\n\n    return overwrites;\n}\n\nexport function clearScene(scene){\n    for (const obj of geometryArray) {\n        scene.remove(obj);\n        obj.geometry.dispose();\n        obj.material.dispose();\n    }\n\n    console.log(scene);\n\n    geometryArray = [];\n}\n\nexport function addBrick() {\n\n    clearScene(scene);\n\n    updateEasingSettings();\n\n    console.log(overwrites);\n\n    const pls = constructBrick(overwrites)\n\n    applyBrickShader(scene, pls, overwrites);\n}\n","import {OrthographicCamera, PerspectiveCamera} from 'three'\n\nexport function getOrthographicCamera(mount) {\n    const {clientWidth, clientHeight} = mount;\n\n    const camera = new OrthographicCamera(\n        clientWidth / -16,\n        clientWidth /16,\n        clientHeight / 16,\n        clientHeight / -16,\n        -1,\n        100\n    );\n\n    camera.enableRotate = false;\n    camera.position.z = 20;\n\n    return camera;\n}\n\nexport function getPerspectiveCamera(mount) {\n    const {clientWidth, clientHeight} = mount;\n\n    const camera = new PerspectiveCamera(\n        45,\n        clientWidth / clientHeight\n    );\n\n    camera.position.z = 500;\n    return camera;\n}\n","import {MOUSE} from 'three';\nimport {OrbitControls} from \"three/examples/jsm/controls/OrbitControls\";\n\nexport function getOrbitControls(camera, renderer) {\n    const orbitControls = new OrbitControls(camera, renderer.domElement);\n    orbitControls.enableRotate = true;\n    orbitControls.enableKeys = true;\n    // orbitControls.minZoom = .5;\n    // orbitControls.maxZoom = 8;\n    // orbitControls.mouseButtons = {ZOOM: MOUSE.MIDDLE, PAN: MOUSE.RIGHT};\n\n    orbitControls.target.set(0, 0);\n    orbitControls.update();\n\n    return orbitControls;\n}\n\n","// defining base parameters\n// all lengths are in mm\n// base height, width\n\nimport {ClayPatternCurve} from \"./clay-pattern-curve\";\nimport {Polyline} from \"../three/three-poly-line\";\nimport {ClayPoint} from \"./clay-point\";\nimport {polylineToPolygon} from \"../jsts2Three/three-to-jsts\";\nimport {createBuffer, geometriesDifference, geometriesIntersection, geometryUnion} from \"../importing-jsts\";\nimport {polygonToPolylines} from \"../jsts2Three/jsts-to-three\";\nimport {Vector2, Vector3} from \"three\";\nimport {overwrites} from \"../three/brick-to-scene\";\n\nfunction pinRadiusAtHeight(p, height) {\n    return p.pinDiameterDelta * height + p.pinDiameter0;\n}\n\nfunction arcClayPt(i, startPhase, angleDelta, radius, basePoint, vVal = 0.) {\n    const baseAngle = angleDelta * i;\n    const angle = startPhase + baseAngle;\n\n    const x0 = Math.cos(angle);\n    const y0 = Math.sin(angle);\n\n    const x = radius * x0;\n    const y = radius * y0;\n\n    const clayPoint = new ClayPoint(\n        new Vector3(basePoint.x + x, basePoint.y + y, basePoint.z),\n        new Vector3(x0, y0, 0)\n    );\n\n    clayPoint.uvValue = new Vector2(vVal + baseAngle * radius, basePoint.z);\n\n    return clayPoint\n}\n\nfunction arcDivisions(radius, goalLength, arcAngle, startPhase, basePoint, clayPoints, vVal = 0.) {\n    const count = Math.ceil(arcAngle * radius / goalLength);\n    const angleDelta = arcAngle / count;\n\n    for (let i = 0; i < count; i++) {\n        const clayPoint = arcClayPt(i, startPhase, angleDelta, radius, basePoint, vVal);\n        clayPoints.push(clayPoint);\n    }\n\n    return arcAngle * radius + vVal;\n}\n\nfunction lineDivisions(v0, v1, goalLength, clayPoints, vVal = 0.) {\n    const length = v0.distanceTo(v1);\n    const count = Math.ceil( length / goalLength);\n\n    const delta = new Vector3().addScaledVector(\n        new Vector3().subVectors(v1, v0),\n        1. / count\n    );\n\n    const deltaLength = delta.length();\n\n    const normal = new Vector3(delta.y / deltaLength, -delta.x / deltaLength);\n\n    for (let i = 0; i < count; i++) {\n        const v = new Vector3().addVectors(\n            v0,\n            new Vector3().addScaledVector(delta, i)\n        );\n\n        const clayPoint = new ClayPoint(v, normal);\n        clayPoint.uvValue = new Vector2(vVal + i * deltaLength, v0.z);\n        clayPoints.push(clayPoint);\n    }\n\n    return length + vVal;\n}\n\nexport function outerProfile(p, height = 0.) {\n    const v0 = new Vector3(-(p.baseLength - p.baseWidth) * .5, 0.0, height);\n    const v1 = new Vector3((p.baseLength - p.baseWidth) * .5, 0.0, height);\n\n    let clayPoints = [];\n\n    let vVal = 0.;\n\n    vVal = arcDivisions(p.baseWidth * .5, p.precision, .5 * Math.PI, Math.PI, v0, clayPoints, vVal);\n\n    const p0 = new Vector3(-(p.baseLength - p.baseWidth) * .5, -p.baseWidth * .5, height);\n    const p1 = new Vector3((p.baseLength - p.baseWidth) * .5, -p.baseWidth * .5, height);\n\n    vVal = lineDivisions(p0, p1, p.precision, clayPoints, vVal);\n\n    vVal = arcDivisions(p.baseWidth * .5, p.precision, Math.PI, -.5 *Math.PI, v1, clayPoints, vVal);\n\n    const p2 = new Vector3((p.baseLength - p.baseWidth) * .5, p.baseWidth * .5, height);\n    const p3 = new Vector3(-(p.baseLength - p.baseWidth) * .5, p.baseWidth * .5, height);\n\n    vVal = lineDivisions(p2, p3, p.precision, clayPoints, vVal);\n\n    arcDivisions(p.baseWidth * .5, p.precision, .5 * Math.PI, .5 * Math.PI, v0, clayPoints, vVal);\n\n    const clayPolyline = new ClayPatternCurve(clayPoints);\n\n    return clayPolyline;\n}\n\nfunction simpleLineDivison(v0, v1, divisions, withEnds = false) {\n    const delta = new Vector3().addScaledVector(\n        new Vector3().subVectors(v1, v0),\n        1. / divisions\n    );\n\n    let vs = [];\n\n    let start = 0;\n    let end = divisions + 1;\n\n    if (!withEnds) {\n        start = 1;\n        end = divisions;\n    }\n\n    for (let i = start; i < end; i++) {\n        const v = new Vector3().addVectors(\n            v0,\n            new Vector3().addScaledVector(delta, i)\n        );\n\n        vs.push(v);\n    }\n\n    return vs;\n}\n\nfunction simpleArcDivision(baseV, radius, arcAngle = Math.PI, startPhase = 0., division = 100) {\n    const delta = arcAngle / division;\n\n    let vs = [];\n\n    for (let i = 0; i < division; i++) {\n        const angle = startPhase + i * delta;\n\n        const x = radius * Math.cos(angle);\n        const y = radius * Math.sin(angle);\n\n        vs.push(new Vector3(baseV.x + x, baseV.y + y, 0));\n    }\n\n    return new Polyline(vs);\n}\n\nfunction diamondPolyline(p, bPoint) {\n    return new Polyline([\n        new Vector3(bPoint.x + p.diamondWidth * .5, bPoint.y, 0),\n        new Vector3(bPoint.x, bPoint.y + p.diamondHeight * .5, 0),\n        new Vector3(bPoint.x - p.diamondWidth * .5, bPoint.y, 0),\n        new Vector3(bPoint.x, bPoint.y - p.diamondHeight * .5, 0)\n    ]);\n}\n\nfunction rectangle(bPoint, width, height) {\n    return new Polyline([\n        new Vector3(bPoint.x + width * .5, bPoint.y + .5 * height, 0),\n        new Vector3(bPoint.x - width * .5, bPoint.y + .5 * height, 0),\n        new Vector3(bPoint.x - width * .5, bPoint.y - .5 *  height, 0),\n        new Vector3(bPoint.x + width * .5, bPoint.y - .5 *  height, 0)\n    ]);\n}\n\nexport function innerProfileGeom(v0, v1, p, height = 0.) {\n\n    const diamondVs = simpleLineDivison(v0, v1, p.diamondCount + 1, false);\n\n    let pls = [];\n\n    for (const diamondV of diamondVs) {\n        const diamond = diamondPolyline(p, diamondV);\n        const diamondRect = rectangle(diamondV, p.productionWidth, p.baseWidth * p.lengthBufferMultiplier);\n\n        pls.push(diamond);\n        pls.push(diamondRect);\n    }\n\n    const pinDiameter = pinRadiusAtHeight(p, height);\n\n    pls.push(simpleArcDivision(v0, pinDiameter * .5, 2. * Math.PI, 0., p.pinDivisions));\n    pls.push(simpleArcDivision(v1, pinDiameter * .5, 2. * Math.PI, 0., p.pinDivisions));\n    pls.push(rectangle(v0, p.productionWidth, p.baseWidth * p.lengthBufferMultiplier));\n    pls.push(rectangle(v1, p.productionWidth, p.baseWidth * p.lengthBufferMultiplier));\n    pls.push(rectangle(new Vector3(0, 0, 0),p.baseLength + p.baseWidth * (p.lengthBufferMultiplier - 1.), p.productionWidth));\n\n    let polygons = [];\n    for (const pl of pls){\n        polygons.push(polylineToPolygon(pl));\n    }\n\n    const geom = geometryUnion(polygons);\n\n    return geom;\n}\n\nexport function innerProfile(v0, v1, p, height = 0.) {\n    const geom = innerProfileGeom(v0, v1, p, height);\n\n    const polylines = polygonToPolylines(geom);\n\n    for (const pl of polylines) {\n        pl.moveToHeight(height);\n    }\n\n    return polylines;\n}\n\nexport function aSlice(v0, v1, p, height = 0.) {\n    const outerClayCurve = outerProfile(p, height);\n\n    outerClayCurve.applyPattern(\n        p.pattern.patternFunction,\n        p.pattern.patternParameters,\n        p.easingParameters\n    );\n\n    const outerGeom = outerClayCurve.toPolygon();\n\n    const bufferedOuterGeom = createBuffer(outerGeom, -p.productionWidth, 1);\n\n    const recL = (p.baseLength + p.baseWidth * (p.lengthBufferMultiplier - 1.)) * .5;\n\n    // console.log(recL);\n\n    const leftRec = rectangle(\n        new Vector3(-recL * .5, 0, 0),\n        recL,\n        p.productionWidth\n    );\n\n    // console.log(leftRec);\n\n    const leftRecPg = polylineToPolygon(leftRec);\n    const unionOuterGeom = geometryUnion([bufferedOuterGeom, leftRecPg])\n\n    const innerGeom = innerProfileGeom(v0, v1, p, height);\n\n    const geom = geometriesIntersection(unionOuterGeom, innerGeom);\n\n    const path = geometriesDifference(outerGeom, geom)\n\n    let polylines = polygonToPolylines(path);\n\n    return polylines;\n}\n\nfunction aPinOnlySlice(v0, v1, p, height) {\n    let pls = [];\n\n    const pinDiameter = pinRadiusAtHeight(p, height);\n\n    const arcA = simpleArcDivision(v0, pinDiameter * .5, 2. * Math.PI, 0., p.pinDivisions);\n    const arcB = simpleArcDivision(v1, pinDiameter * .5, 2. * Math.PI, 0., p.pinDivisions);\n\n    arcA.cadFlip();\n    arcB.cadFlip();\n\n    pls.push(arcA);\n    pls.push(arcB);\n\n    return pls;\n}\n\nexport function constructBrick(p) {\n    const v0 = new Vector3(-p.pinSpacing * .5, 0.0);\n    const v1 = new Vector3(p.pinSpacing * .5, 0.0);\n\n    p.pinDiameterDelta = (p.pinDiameter1 - p.pinDiameter0) / p.pinDelta;\n\n    let polylines = [];\n\n    let localH = 0.;\n    for (localH; localH < p.bodyHeight; localH += p.layerHeight) {\n\n        for (const pl of aSlice(v0, v1, p, localH)) {\n            pl.moveToHeight(localH + p.startHeight);\n            polylines.push(pl);\n        }\n    }\n\n    for (localH; localH < p.totalHeight; localH += p.layerHeight) {\n        for (const pl of aPinOnlySlice(v0, v1, p, localH)) {\n            pl.moveToHeight(localH + p.startHeight);\n            polylines.push(pl);\n        }\n    }\n\n    return polylines;\n}\n\n","import {GUI} from \"three/examples/jsm/libs/dat.gui.module\";\nimport {USDZExporter} from \"three/examples/jsm/exporters/USDZExporter\";\nimport {\n    addBrick,\n    clearScene,\n    OVERWRITE_SETTINGS,\n    overwrites,\n    updateEasingSettings\n} from \"../geometry/three/brick-to-scene\";\nimport {PATTERN_LIST} from \"../geometry/clayBrick/clay-patterns\";\n\nexport function createGUI(scene) {\n    const gui = new GUI({ autoPlace: true, width: 150 });\n\n    for (const patternName in PATTERN_LIST) {\n        const localPatternGUI = gui.addFolder(patternName);\n\n        for (const patternParameter in PATTERN_LIST[patternName].patternParameters) {\n            console.log(patternParameter);\n\n            addPatternOverwrites(localPatternGUI, patternParameter, patternName);\n        }\n    }\n\n    const defaultParameters = gui.addFolder(\"constructionParameters\");\n\n    for (const overwriteName in overwrites) {\n        if (overwriteName !== \"pattern\" && OVERWRITE_SETTINGS.hasOwnProperty(overwriteName)) {\n            addAllOverwrites(defaultParameters, overwriteName);\n        }\n    }\n}\n\nfunction addAllOverwrites(guiElement, overwriteElement) {\n    guiElement.add(\n        overwrites,\n        overwriteElement,\n        overwrites[overwriteElement].min,\n        overwrites[overwriteElement].max\n    ).onChange(function (value) {\n        overwrites[overwriteElement] = value;\n        // updateEasingSettings();\n\n        addBrick();\n    });\n}\n\nfunction addPatternOverwrites(guiElement, overwritePatternElement, patternName) {\n\n    const patternParameters = PATTERN_LIST[patternName].patternParameters;\n\n    console.log(patternName);\n\n    overwrites.pattern.patternParameters[overwritePatternElement] = patternParameters[overwritePatternElement].default;\n\n    const slider = guiElement.add(\n        overwrites.pattern.patternParameters,\n        overwritePatternElement,\n        patternParameters[overwritePatternElement].min,\n        patternParameters[overwritePatternElement].max\n    );\n\n    slider.onChange(function (value) {\n        overwrites.pattern.patternFunction = PATTERN_LIST[patternName].patternFunction;\n        overwrites.pattern.patternParameters[overwritePatternElement] = value;\n        // updateEasingSettings();\n\n        addBrick();\n    });\n}\n","import React, {useEffect, useRef} from 'react';\nimport Measure from 'react-measure';\nimport {cleanUp, setUp} from \"./three-setup/set-up\";\nimport {resize} from \"./three-setup/renderers\";\nimport {GUI} from 'three/examples/jsm/libs/dat.gui.module';\nimport {createGUI} from \"./three-setup/gui-setup\";\n\nimport './Viewer.scss';\n\nfunction Viewer() {\n    const mount = useRef(null);\n    const rendererRef = useRef(null);\n    const cameraRef = useRef(null);\n\n    let gui;\n\n\n    useEffect(() => {\n        console.log(mount);\n\n        const {scene, camera, renderer, frameId} = setUp(mount);\n\n        rendererRef.current = renderer;\n        cameraRef.current = camera;\n\n        gui = createGUI(scene);\n\n        return () => {\n            cleanUp(mount, renderer, frameId);\n        }\n    }, [rendererRef, cameraRef]);\n\n    return (\n        <Measure\n            bounds\n            onResize={() => {\n                resize(mount, rendererRef.current, cameraRef.current)\n            }}>\n            {({measureRef}) => (\n                <div className={'simple-3d'} ref={measureRef}>\n                    <div className={'three-canvas'} ref={mount} tabIndex={0}/>\n                </div>\n            )}\n        </Measure>\n    )\n}\n\nexport default Viewer;\n","// ... App.js\nimport React, {Component} from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as THREE from \"three\";\nimport {TestGeo} from \"./geometry/test-geo\";\nimport {setUp} from \"./three-setup/set-up\";\n\nimport './App.css';\nimport Viewer from \"./Viewer\";\n\nfunction App() {\n    return (\n        <div className={'app'}>\n            <div className={'container'}>\n                <Viewer/>\n            </div>\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}