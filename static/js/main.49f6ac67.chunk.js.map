{"version":3,"sources":["geometry/shaders-materials.js","geometry/jstsOperations/importing-jsts.js","geometry/clayBrick/clay-point.js","geometry/three/three-poly-line.js","geometry/clayBrick/clay-patterns.js","geometry/clayBrick/clay-pattern-curve.js","geometry/jsts2Three/jsts-to-three.js","geometry/jsts2Three/three-to-jsts.js","three-setup/renderers.js","three-setup/set-up.js","three-setup/render-loops.js","geometry/three/brick-to-scene.js","three-setup/cameras.js","three-setup/orbit-controls.js","geometry/jstsOperations/deconstruct-polygon.js","geometry/clayBrick/clay-simple-base.js","three-setup/gui-setup.js","geometry/io/export-to-csv.js","Viewer.js","App.js","reportWebVitals.js","index.js"],"names":["triangulationFromPolygon","polygon","builder","DelaunayTriangulationBuilder","setSites","setTolerance","getTriangles","GeometryFactory","edgesFromTriangulation","triangulation","vertexDict","vPairs","pureVertices","boundary","_geometries","coords","getGeometryN","getCoordinates","length","cMap","idx","coor","coordinate","JSON","stringify","x","y","z","dictCount","Object","keys","Vector3","a","b","v0","Math","min","v1","max","idxVertex","v","lines","localLineCurve","LineCurve","push","bufferFromTriangulation","bufferGeo","BufferGeometry","coordinatesList","vertices","Float32Array","setAttribute","BufferAttribute","computeVertexNormals","createBuffer","geom","radius","segments","BufferOp","bufferOp","geometriesDifference","geosA","geosB","difference","geometriesIntersection","intersection","geometryUnion","geos","collection","createGeometryCollection","union","geometriesUnion","UnaryUnionOp","multiplePoints","strings","reader","WKTReader","aString","read","readWKString","bufferedGeos","geo","displayPointTest","plg","buffer","edges","triangulatePolyline","ClayPoint","origin","direction","this","position","copy","value","addVectors","addScaledVector","Coordinate","Polyline","Curve","points","closed","init","dirs","getDirs","arcLengthDivisions","getPointCount","dirList","i","vDir","subVectors","lengths","getLengths","cacheArcLengths","needsUpdate","previous","u","optionalTarget","getTangent","t","vT","locT","roundT","isNaN","normalize","set","tangents","normals","binormals","vec","mat","Matrix4","getTangentAt","crossVectors","clone","Number","EPSILON","theta","acos","clamp","dot","applyMatrix4","makeRotationAxis","t0","getPoint","_tConstraining","height","point","periods","amplitude","step","PI","phase","sin","pt","sinWaveUVPattern","uv","parameters","phaseDelta","period","offset","unitRadiusForDot","localU","localV","baseU","uSpacing","baseV","vSpacing","positionShift","abs","dotForUV","radiusScaleV","localDistance","sqrt","edgeUVConstraining","easingParameters","endLength","startLength","startMaxLength","endMaxLength","easingDelta","DEFAULT_SIN_WAVE_UV_PARAMETERS","default","DEFAULT_UV_DOT_PARAMETERS","PATTERN_LIST","patternParameters","patternFunction","dotPyramidUVPattern","dotEllipsoidUVPattern","locRadius","dotInverseUVPattern","cylinderUVFunction","radiusA","radiusB","localR","round","dotCylinderForUV","rD","ClayPatternCurve","clayPoints","coordinates","toCoordinate","createPolygon","positions","toVector3","edgeValue","uvValue","createLinearRing","vectorFromCoordinate","locZ","linearRingToPolyline","linearRing","vectors","pop","deconstructPolygon","linearRings","constructor","name","llrs","concat","getExteriorRing","getNumInteriorRing","getInteriorRingN","getLinearRings","polylineToPolygon","polyline","vector3","coordinatesFromPolyline","resize","mount","renderer","camera","current","clientWidth","clientHeight","aspect","updateProjectionMatrix","setSize","scene","start","frameId","requestAnimationFrame","animate","clear","render","setUp","Scene","light","directionalLight","DirectionalLight","castShadow","shadow","near","far","bias","mapSize","width","addLighting","add","addBrick","WebGL1Renderer","antialias","alpha","setPixelRatio","window","devicePixelRatio","shadowMap","enabled","type","PCFShadowMap","getPerspectiveRenderer","appendChild","domElement","PerspectiveCamera","getPerspectiveCamera","orbitControls","OrbitControls","enableRotate","enableKeys","target","update","getOrbitControls","cleanUp","cancelAnimationFrame","stop","removeChild","overwrites","geometryArray","OVERWRITE_SETTINGS","productionWidth","baseWidth","baseLength","lengthBufferMultiplier","pinSpacing","diamondWidth","diamondHeight","diamondCount","pinDiameter0","pinDiameter1","pinDelta","pinDivisions","precision","bodyHeight","totalHeight","startHeight","layerHeight","easingStart","easingEnd","pattern","patternClone","patternSettingsClone","key","updateEasingSettings","locTotalLength","obj","remove","geometry","dispose","material","console","log","clearScene","pls","constructBrick","loader","TextureLoader","pipeRadius","load","texture","brickShader","MeshLambertMaterial","map","pl","tubeGeo","TubeGeometry","locMesh","Mesh","receiveShadow","undefined","err","error","applyBrickShader","overwriteClone","geoFactory","splitLineStringWithPoint","lineString","circle","creatCircle","mls","lrs","joinLineStrings","coord","createPoint","getEnvelopes","lrA","lrB","bboxA","getEnvelopeInternal","bboxB","switchingFunctionMap","top","getMaxY","getMinY","bottom","left","getMaxX","getMinX","right","small","getArea","large","checkFunction","functionName","sameOrder","inverseOrder","sortGeometries","sort","mergeTouchingLineStrings","createLineString","getNumGeometries","deconstructMultiLineString","hasBeenJoined","joinedLrs","lr","includes","locLr","endPoint","getEndPoint","getCoordinate","startPoint","getStartPoint","distance","hardcodedTweaking","intermediateLrs","activeLr","resultLrs","reverse","v2","subIntermediate","v3","output","count","d","lr0","lr1","localResults","flippedCurves","concatenateLineStrings","twistIntersect","p","activeLR","pinDiameterAtHeight","pinDiameterDelta","arcClayPt","startPhase","angleDelta","basePoint","vVal","baseAngle","angle","x0","cos","y0","clayPoint","Vector2","arcDivisions","goalLength","arcAngle","ceil","lineDivisions","distanceTo","delta","deltaLength","normal","outerProfile","p0","p1","p2","p3","clayPolyline","simpleLineDivison","divisions","withEnds","relativeShift","vs","end","simpleArcDivision","division","diamondPolyline","bPoint","rectangle","innerProfileGeom","pinR","diamondVs","diamondV","diamond","diamondRect","polygons","generateCrossPin","spacing","aSlice","outerClayCurve","applyPattern","outerGeom","toPolygon","bufferedOuterGeom","recL","leftRec","leftRecPg","unionOuterGeom","innerGeom","path","diamondCrosses","lineStrings","polyLines","coordinateLists","aPinOnlySlice","pinDiameter","arcA","arcB","cadFlip","polylines","coordinatListss","localH","moveToHeight","createGUI","gui","GUI","autoPlace","patternName","localPatternGUI","addFolder","patternParameter","addPatternOverwrites","defaultParameters","overwriteName","hasOwnProperty","addAllOverwrites","download","encodedUri","encodeURI","csvContent","toString","outputCSV","link","document","createElement","body","click","addCSVOutput","guiElement","overwriteElement","onChange","overwritePatternElement","Viewer","useRef","rendererRef","cameraRef","useEffect","bounds","onResize","measureRef","className","ref","tabIndex","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.49f6ac67.chunk.js","sourcesContent":["export const shaders = {\n    normalShader: {\n        vertexShader: `\n            varying vec3 v_Normal;\n            void main() {\n                v_Normal = normal;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            varying vec3 v_Normal;\n            void main() {\n                gl_FragColor = vec4(v_Normal * .8, .8);\n                // vec3 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);\n    \n            }`,\n        transparent: true,\n        uniforms: {}\n    },\n\n    smokeShader: {\n        fragmentShader: `\n            uniform vec2 res;\n            uniform sampler2D bufferTexture;\n            uniform vec3 smokeSource;\n            \n            void main() {\n                vec2 pixel = gl_FragCoord.xy / res.xy;\n                gl_FragColor = texture2D( bufferTexture, pixel );\n            \n                //Get the distance of the current pixel from the smoke source\n                float dist = distance(smokeSource.xy,gl_FragCoord.xy);\n                //Generate smoke when mouse is pressed\n                gl_FragColor.rgb += smokeSource.z * max(15.0-dist,0.0);\n            \n                //Smoke diffuse\n                float xPixel = 1.0/res.x;//The size of a single pixel\n                float yPixel = 1.0/res.y;\n                vec4 rightColor = texture2D(bufferTexture,vec2(pixel.x+xPixel,pixel.y));\n                vec4 leftColor = texture2D(bufferTexture,vec2(pixel.x-xPixel,pixel.y));\n                vec4 upColor = texture2D(bufferTexture,vec2(pixel.x,pixel.y+yPixel));\n                vec4 downColor = texture2D(bufferTexture,vec2(pixel.x,pixel.y-yPixel));\n                //Diffuse equation\n                gl_FragColor.rgb += 14.0 * 0.016 * (leftColor.rgb + rightColor.rgb + downColor.rgb + upColor.rgb - 4.0 * gl_FragColor.rgb);\n            }`\n    },\n\n    gridNormal: {\n        vertexShader: `\n            varying vec3 v_Position;\n            varying vec3 v_Normal;\n            void main() {\n                v_Position = position;\n                v_Normal = normal;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            varying vec3 v_Position;\n            varying vec3 v_Normal;\n            void main() {\n                vec3 grid = abs(fract(v_Position - 0.5) - 0.5) / fwidth(v_Position);\n                float line = min(min(grid.x, grid.y), grid.z);\n                float value = 3.- min(line,3.);\n                float transparency = .1 + value * .9;\n            \n                gl_FragColor = vec4(v_Normal * value, transparency);\n                // vec3 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);\n            }`,\n        transparent: true,\n        uniforms: {},\n        extensions: {derivatives: true}\n    },\n\n    grid: {\n        vertexShader: `\n            varying vec3 v_Position;\n            void main() {\n                v_Position = position;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            varying vec3 v_Position;\n            void main() {\n                vec3 grid = abs(fract(v_Position - .5) - .5) / fwidth(v_Position);\n                float line = min(min(grid.x, grid.y), grid.z);\n                float value = 2.5- min(line, 2.5);\n                float transparency = .1 + value * .9;\n\n                gl_FragColor = vec4(vec3(0.), transparency);\n                // vec3 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);\n            }`,\n        transparent: true,\n        uniforms: {},\n        extensions: {derivatives: true}\n    },\n\n    zGrid: {\n        vertexShader: `\n            varying float z_Position;\n            varying vec3 v_Normal;\n            void main() {\n                z_Position = position.z;\n                v_Normal = normal;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            varying float z_Position;\n            varying vec3 v_Normal;\n            void main() {\n                float line = abs(fract(z_Position - 0.5) - 0.5) / fwidth(z_Position);\n                float value = 3.- min(line,3.);\n                float transparency = .1 + value * .9;\n    \n                gl_FragColor = vec4(v_Normal * value, transparency);\n                // vec3 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);\n            }`,\n        transparent: true,\n        uniforms: {},\n        extensions: {derivatives: true}\n    },\n\n    edges: {\n        vertexShader: `\n            attribute vec2 barycentric;\n            varying vec2 b;\n            void main () {\n                b = barycentric;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            // float gridFactor (vec2 vBC, float width, float feather) {\n            //     float w1 = width - feather * 0.5;\n            //     vec3 bary = vec3(vBC.x, vBC.y, 1.0 - vBC.x - vBC.y);\n            //     vec3 d = fwidth(bary);\n            //     vec3 a3 = smoothstep(d * w1, d * (w1 + feather), bary);\n            //    \n            //     return min(min(a3.x, a3.y), a3.z);\n            // }\n            \n            float gridFactor (vec2 vBC, float width) {\n                vec3 bary = vec3(vBC.x, vBC.y, 1.0 - vBC.x - vBC.y);\n                vec3 d = fwidth(bary);\n                vec3 a3 = smoothstep(d * (width - 0.5), d * (width + 0.5), bary);\n                \n                return min(min(a3.x, a3.y), a3.z);\n            }\n            \n            varying vec2 b;\n            \n            void main () {\n                gl_FragColor = vec4(vec3(gridFactor(b, 1.0) * .6), 1);\n            }`,\n        transparent: true,\n        extensions: {derivatives: true}\n    }\n}\n","import {DelaunayTriangulationBuilder} from \"jsts/org/locationtech/jts/triangulate\";\nimport {WKTReader} from \"jsts/org/locationtech/jts/io\";\nimport BufferOp from \"jsts/org/locationtech/jts/operation/buffer/BufferOp\";\nimport {Geometry, GeometryCollection, GeometryFactory} from \"jsts/org/locationtech/jts/geom\";\nimport \"jsts/org/locationtech/jts/monkey.js\";\nimport {BufferAttribute, BufferGeometry, LineCurve, Vector3} from \"three\";\nimport {CustomLine} from \"../test-geo\";\nimport {UnaryUnionOp} from \"jsts/org/locationtech/jts/operation/union\";\n\nfunction triangulationFromPolygon(polygon) {\n    const builder = new DelaunayTriangulationBuilder();\n\n    builder.setSites(polygon);\n    builder.setTolerance(.01);\n\n    let triangulation = builder.getTriangles(new GeometryFactory());\n\n    // console.log(triangulation);\n\n    return triangulation;\n}\n\nfunction polygonToBufferGeometry(polygon) {\n    const triangulation = triangulationFromPolygon(polygon);\n    return bufferFromTriangulation(triangulation);\n}\n\nfunction edgesFromTriangulation(triangulation) {\n    let vertexDict = {};\n    let vPairs = {};\n    let pureVertices = {};\n\n    for (const boundary in triangulation._geometries) {\n        const bnd = triangulation.getGeometryN(boundary);\n        const coords = bnd.getCoordinates();\n\n        if (coords.length === 4) {\n            let cMap = [0, 0, 0];\n            for (const idx in [0,1,2]) {\n                const coor = coords[idx];\n\n                let coordinate = JSON.stringify({x: coor.x, y: coor.y, z: .1});\n\n                const dictCount = Object.keys(vertexDict).length;\n\n                if (!(coordinate in vertexDict)) {\n                    // console.log(coordinate);\n\n                    vertexDict[coordinate] = dictCount;\n                    pureVertices[coordinate] = new Vector3(coor.x, coor.y, .1);\n                    cMap[idx] = dictCount;\n                } else {\n                    cMap[idx] = vertexDict[coordinate];\n                }\n            }\n\n            // console.log(cMap);\n\n            for (const idx in [0,1,2]) {\n                let a = cMap[idx];\n                let b = cMap[(idx + 1) % 3];\n\n                let v0 = Math.min(a, b);\n                let v1 = Math.max(a, b);\n\n                vPairs[JSON.stringify([v0, v1])] = [v0, v1];\n            }\n        }\n    }\n\n    let idxVertex = {};\n    for(const v in vertexDict){\n        const idx = vertexDict[v];\n        idxVertex[idx] = pureVertices[v];\n    }\n\n    let lines = [];\n\n    for (const idx in vPairs) {\n        // console.log(vPairs[idx]);\n\n        const a = vPairs[idx][0];\n        const b = vPairs[idx][1];\n\n        // console.log(vPairs);\n        // console.log(a, b);\n        // console.log(idxVertex[a], idxVertex[b]);\n\n        const localLineCurve = new LineCurve(idxVertex[a], idxVertex[b]);\n\n        // localLineCurve.arcLengthDivisions = 1;\n\n        lines.push(localLineCurve);\n    }\n\n    return lines;\n}\n\nfunction bufferFromTriangulation(triangulation) {\n    // let geoCollection = new GeometryCollection();\n\n    let bufferGeo = new BufferGeometry();\n    let coordinatesList = [];\n\n    for (const boundary in triangulation._geometries) {\n        const bnd = triangulation.getGeometryN(boundary);\n        const coords = bnd.getCoordinates();\n\n        if (coords.length === 4) {\n            for (const idx in [0,1,2]) {\n                const coor = coords[idx];\n                coordinatesList.push(coor.x);\n                coordinatesList.push(coor.y);\n                coordinatesList.push(.1);\n            }\n        }\n    }\n\n    const vertices = new Float32Array( coordinatesList );\n\n    bufferGeo.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n    bufferGeo.computeVertexNormals();\n\n    return bufferGeo;\n}\n\nexport function createBuffer(geom, radius, segments = 32) {\n    return BufferOp.bufferOp(geom, radius, segments);\n}\n\nexport function displayPoint(aString) {\n    let reader = new WKTReader();\n\n    let pt = reader.read(aString);\n\n    let buffered = createBuffer(pt, 20);\n\n    const triangulation = triangulationFromPolygon(buffered);\n\n    return {\n        buffer: bufferFromTriangulation(triangulation),\n        edges: edgesFromTriangulation(triangulation)\n    };\n}\n\nexport function geometriesUnion(geos) {\n    if (geos.length === 1){\n        return geos[0];\n    }\n\n    const geoFac = new GeometryFactory();\n    const geoCollection = geoFac.createGeometryCollection(geos).union();\n\n    return geoCollection;\n}\n\nexport function geometriesDifference(geosA, geosB) {\n    return geosA.difference(geosB);\n}\n\nexport function geometriesIntersection(geosA, geosB) {\n    return geosA.intersection(geosB);\n}\n\nexport function readWKString(strings) {\n    const reader = new WKTReader();\n    const geos = [];\n\n    for (const aString of strings) {\n        geos.push(reader.read(aString));\n    }\n\n    return geos;\n}\n\nexport function geometryUnion(geos) {\n    const collection = geometriesUnion(geos);\n\n    return UnaryUnionOp.union(collection);\n}\n\nexport function multiplePoints(){\n    const strings = [\n        'POINT (-20 0)',\n        'POINT (20 0)',\n        'POINT (0 15)'\n    ];\n\n    const geos = readWKString(strings);\n    let bufferedGeos = [];\n\n    for (const geo of geos) {\n        bufferedGeos.push(BufferOp.bufferOp(geo, 30, 100));\n    }\n\n    const geom = geometryUnion(bufferedGeos);\n\n    return geom;\n}\n\nexport function triangulatePolyline(plg) {\n    const triangulation = triangulationFromPolygon(plg);\n\n    return {\n        buffer: bufferFromTriangulation(triangulation),\n        edges: edgesFromTriangulation(triangulation)\n    };\n}\n\nexport function testPolygon() {\n    // let reader = new WKTReader();\n    //\n    // const pt = reader.read('POINT (0 0)');\n    // const buffer = BufferOp.bufferOp(pt, 30)\n\n    return multiplePoints();\n}\n\nexport function displayPointTest(){\n    return triangulatePolyline(multiplePoints());\n}\n","import {Vector3} from \"three\";\nimport {Coordinate} from \"jsts/org/locationtech/jts/geom\";\n\nexport class ClayPoint {\n    origin;\n    direction;\n    position;\n    uvValue;\n\n    constructor(origin, direction) {\n        this.origin = origin;\n        this.position = new Vector3().copy(origin);\n        this.direction = direction;\n    }\n\n    move(value) {\n        this.position = new Vector3().addVectors(\n            this.position,\n            new Vector3().addScaledVector(this.direction, value)\n        );\n    }\n\n    set(value) {\n        this.position = new Vector3().addVectors(\n            this.origin,\n            new Vector3().addScaledVector(this.direction, value)\n        );\n    }\n\n    toCoordinate() {\n        return new Coordinate(\n            this.position.x,\n            this.position.y,\n            this.position.z\n        )\n    }\n\n    toVector3() {\n        return new Vector3(this.position.x, this.position.z, -this.position.y);\n    }\n}\n\nexport function clayPointTest() {\n    const vBase = new Vector3(0, 0, 0);\n    const vDir = new Vector3(1, 0, 0);\n\n    const clayPoint = new ClayPoint(vBase, vDir);\n\n    clayPoint.move(1.);\n\n    clayPoint.set(10.);\n}\n","import {Curve, Matrix4, Vector3} from \"three\";\nimport {clamp} from \"three/src/math/MathUtils\";\n\nexport class CustomSinCurve extends Curve {\n\n    constructor( scale = 1 ) {\n\n        super();\n\n        this.scale = scale;\n\n    }\n\n    getPoint( t, optionalTarget = new Vector3() ) {\n\n        const tx = t * 3 - 1.5;\n        const ty = Math.sin( 2 * Math.PI * t );\n        const tz = 0;\n\n        return optionalTarget.set( tx, ty, tz ).multiplyScalar( this.scale );\n    }\n}\n\nexport class CustomLine extends Curve {\n\n    constructor(v0, v1) {\n        super();\n\n        this.v0 = v0;\n        this.vDir = v1 - this.v0;\n\n        this.scale = 1.;\n    }\n\n    getPoint(t, optionalTarget = new Vector3()) {\n        const v = this.v0 + t * this.vDir;\n        // console.log(v);\n\n        return optionalTarget.set(v.x, v.y, v.z).multiplyScalar( this.scale );\n    }\n}\n\nexport class Polyline extends Curve {\n    constructor(points, closed = true) {\n        super();\n\n        this.points = points;\n        this.closed = closed;\n\n        this.init();\n    }\n\n    init() {\n        this.dirs = this.getDirs();\n\n        this.arcLengthDivisions = this.getPointCount();\n    }\n\n    getPointCount() {\n        if (this.closed) {\n            return this.points.length;\n        } else {\n            return this.points.length - 1;\n        }\n    }\n\n    getDirs() {\n        let dirList = [];\n\n        for (let i = 0; i < this.getPointCount(); i++) {\n            const v0 = this.points[i];\n            const v1 = this.points[(i+1) % this.getPointCount()];\n\n            const vDir = new Vector3().subVectors(v1, v0);\n\n            dirList.push(vDir);\n        }\n\n        return dirList;\n    }\n\n    getLength() {\n        const lengths = this.getLengths();\n        return lengths[lengths.length - 1];\n    }\n\n    getLengths() {\n        if ( this.cacheArcLengths &&\n            ( this.cacheArcLengths.length === this.getPointCount() + 1 ) &&\n            ! this.needsUpdate ) {\n\n            return this.cacheArcLengths;\n        }\n\n        let previous = 0.;\n        this.cacheArcLengths = [previous];\n\n        for (const dir of this.dirs) {\n            previous += dir.length();\n            this.cacheArcLengths.push(previous);\n        }\n\n        return this.cacheArcLengths;\n    }\n\n    getTangentAt(u, optionalTarget = new Vector3()) {\n        return this.getTangent(u * this.getPointCount(), optionalTarget)\n    }\n\n    getTangent(t, optionalTarget = new Vector3()) {\n        const locT = t % 1.;\n        let roundT = t - t % 1.;\n\n        if (isNaN(t)) {\n            return null;\n        }\n\n        let vT;\n\n        if (t > 0 && t < this.getPointCount()) {\n            if ( locT < .0001 ) {\n                const v1 = new Vector3().copy(this.dirs[roundT]);\n                const v0 = new Vector3().copy(this.dirs[roundT - 1]);\n\n                v0.normalize();\n                v1.normalize();\n\n                vT = new Vector3().addVectors(v0, v1);\n            } else {\n                vT = new Vector3().copy(this.dirs[roundT]);\n            }\n        }\n\n        if (this.closed) {\n            roundT %= this.getPointCount();\n\n            if ( locT < .0001 ) {\n                const v1 = new Vector3().copy(this.dirs[roundT]);\n                const v0 = new Vector3().copy(this.dirs[(roundT + this.getPointCount() - 1) % this.getPointCount()]);\n\n                v0.normalize();\n                v1.normalize();\n\n                vT = new Vector3().addVectors(v0, v1);\n            } else {\n                vT = new Vector3().copy(this.dirs[roundT]);\n            }\n        } else {\n            if (t < 1) {\n                vT = new Vector3().copy(this.dirs[0]);\n            } else {\n                vT = new Vector3().copy(this.dirs[this.dirs.length - 1]);\n            }\n        }\n\n        vT.normalize();\n        return optionalTarget.set(vT.x, vT.y, vT.z);\n    }\n\n    computeFrenetFrames( segments, closed ) {\n\n        // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n        // const normal = new Vector3(0., 0., 1.);\n\n        const tangents = [];\n        const normals = [];\n        const binormals = [];\n\n        const vec = new Vector3();\n        const mat = new Matrix4();\n\n        // compute the tangent vectors for each segment on the curve\n\n        for ( let i = 0; i <= segments; i ++ ) {\n\n            const u = i / segments;\n\n            tangents[ i ] = this.getTangentAt( u, new Vector3() );\n\n        }\n\n        // select an initial normal vector perpendicular to the first tangent vector,\n        // and in the direction of the minimum tangent xyz component\n\n        normals[ 0 ] = new Vector3(0., 1., 0.);\n        binormals[ 0 ] = new Vector3();\n        // let min = Number.MAX_VALUE;\n        // const tx = Math.abs( tangents[ 0 ].x );\n        // const ty = Math.abs( tangents[ 0 ].y );\n        // const tz = Math.abs( tangents[ 0 ].z );\n        //\n        // if ( tx <= min ) {\n        //\n        //     min = tx;\n        //     normal.set( 1, 0, 0 );\n        //\n        // }\n        //\n        // if ( ty <= min ) {\n        //\n        //     min = ty;\n        //     normal.set( 0, 1, 0 );\n        //\n        // }\n        //\n        // if ( tz <= min ) {\n        //\n        //     normal.set( 0, 0, 1 );\n        //\n        // }\n\n        // vec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n        // normals[ 0 ].crossVectors( tangents[ 0 ], vec );\n        binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n        // compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n        for ( let i = 1; i <= segments; i ++ ) {\n\n            normals[ i ] = normals[ i - 1 ].clone();\n\n            binormals[ i ] = binormals[ i - 1 ].clone();\n\n            vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n            if ( vec.length() > Number.EPSILON ) {\n\n                vec.normalize();\n\n                const theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n                normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n            }\n\n            binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n        }\n\n        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n        if ( closed === true ) {\n\n            let theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n            theta /= segments;\n\n            if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n                theta = - theta;\n\n            }\n\n            for ( let i = 1; i <= segments; i ++ ) {\n\n                // twist a little...\n                normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n                binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n            }\n        }\n\n        return {\n            tangents: tangents,\n            normals: normals,\n            binormals: binormals\n        };\n\n    }\n\n    _tConstraining(t) {\n        let locT = t % 1.;\n\n        let t0 = t - locT;\n\n        if (this.closed) {\n            t0 %= this.getPointCount();\n        } else {\n            if (t0 < 0) {\n                locT += t0;\n                t0 = 0;\n            } else if (t0 >= this.getPointCount()) {\n                locT += t0 - this.getPointCount();\n                t0 = this.getPointCount();\n            }\n        }\n\n        return {\n            locT: locT,\n            t0: t0\n        };\n    }\n\n    getPointAt(t, optionalTarget = new Vector3() ) {\n        return this.getPoint(t, optionalTarget);\n    }\n\n    getPoint( t, optionalTarget = new Vector3() ) {\n        t *= this.getPointCount();\n\n        const {locT, t0} = this._tConstraining(t);\n\n        const v0 = this.points[t0];\n        const vDir = this.dirs[t0];\n\n        const v = new Vector3().addVectors(v0, new Vector3().addScaledVector(vDir, locT));\n\n        return optionalTarget.set(v.x, v.y, v.z);\n    }\n\n    moveToHeight(height = 0.){\n        for (const point of this.points) {\n            point.y = height;\n        }\n    }\n\n    makeMeWave(periods = 2., amplitude = 5.) {\n        const step = (periods * 2. * Math.PI) / this.getPointCount();\n        let phase = 0.;\n\n        for (let i = 0; i < this.getPointCount(); i++ ) {\n            this.points[i].z += amplitude * Math.sin(phase);\n            phase += step;\n        }\n\n        this.init();\n    }\n\n    cadFlip() {\n        for (const pt of this.points) {\n            pt.set(pt.x, pt.z, -pt.y);\n        }\n    }\n}\n","export function sinWaveUVPattern(uv, parameters) {\n    const phase = parameters.phaseDelta * uv.y;\n    return Math.sin(uv.x * Math.PI / parameters.period + phase) * parameters.amplitude + parameters.offset;\n}\n\n// function that gives the distance to the closest point in the UV grid\nfunction dotForUV(uv, parameters) {\n    let localU, localV;\n\n    localU = (uv.x - parameters.baseU % parameters.uSpacing) % parameters.uSpacing - parameters.uSpacing * .5;\n    localV = (uv.y - parameters.baseV % parameters.vSpacing) % parameters.vSpacing - parameters.vSpacing * .5;\n\n    if (parameters.positionShift) {\n        if ( (Math.abs(localU) / parameters.uSpacing + Math.abs(localV) / parameters.vSpacing ) > .5 ) {\n            if (localU < 0.) {\n                localU = -parameters.uSpacing * .5 - localU;\n            } else {\n                localU = parameters.uSpacing * .5 - localU;\n            }\n            if (localV < 0.) {\n                localV = -parameters.vSpacing * .5 - localV;\n            } else {\n                localV = parameters.vSpacing * .5 - localV;\n            }\n        }\n    }\n\n    return {\n        localU: localU,\n        localV: localV\n    }\n}\n\nfunction dotCylinderForUV(uv, parameters) {\n    let localU, localV;\n\n    localU = (uv.x - parameters.baseU % parameters.uSpacing) % parameters.uSpacing;\n    localV = (uv.y - parameters.baseV % parameters.vSpacing) % parameters.vSpacing - parameters.vSpacing * .5;\n\n    if (parameters.positionShift){\n        if (Math.round((uv.y - localV) / parameters.vSpacing) % 2. === 1.) {\n            localU += parameters.uSpacing * .5;\n            localU %= parameters.uSpacing;\n        }\n    }\n\n    localU -= parameters.uSpacing * .5;\n\n    return {\n        localU: localU,\n        localV: localV\n    }\n}\n\nfunction unitRadiusForDot(uv, parameters) {\n    let {localU, localV} = dotForUV(uv, parameters);\n\n    localV *= parameters.radiusScaleV;\n\n    const localDistance = Math.sqrt(localU * localU + localV * localV);\n\n    if (localDistance > parameters.radius) {\n        return 0.;\n    } else {\n        return 1. - localDistance / parameters.radius;\n    }\n}\n\nexport function dotPyramidUVPattern(uv, parameters) {\n    const locRadius = unitRadiusForDot(uv, parameters);\n    return locRadius * parameters.amplitude;\n}\n\nexport function dotEllipsoidUVPattern(uv, parameters) {\n    const locRadius = unitRadiusForDot(uv, parameters);\n    return Math.sqrt(1. - (1. - locRadius) ** 2) * parameters.amplitude;\n}\n\nexport function dotInverseUVPattern(uv, parameters) {\n    const locRadius = unitRadiusForDot(uv, parameters);\n    return (1. - Math.sqrt(1. - locRadius ** 2)) * parameters.amplitude;\n}\n\nexport function edgeUVConstraining(uv, easingParameters) {\n    const length = uv.x;\n    if (length >= easingParameters.endLength | length <= easingParameters.startLength){\n        return 0.;\n    } else if (length >= easingParameters.startMaxLength & length <= easingParameters.endMaxLength){\n        return 1.;\n    } else if (length < easingParameters.startMaxLength) {\n        return (length - easingParameters.startLength) * easingParameters.easingDelta;\n    } else if (length > easingParameters.endMaxLength) {\n        return 1. - (length - easingParameters.endMaxLength) * easingParameters.easingDelta;\n    } else {\n        return null;\n    }\n}\n\nexport function cylinderUVFunction(uv, parameters) {\n    let {localU, localV} = dotCylinderForUV(uv, parameters);\n\n    const rD = parameters.radiusB - parameters.radiusA;\n\n    localU = Math.abs(localU);\n    let localR;\n\n    if (Math.abs(localV) + 0.001 < parameters.height * .5) {\n        localR = parameters.radiusA + rD * (localV / parameters.height + .5);\n    } else {\n        localR = -1.;\n    }\n\n    if (localU > localR) {\n        return 0.;\n    } else {\n        return (1 - (localU / localR) ** 2.) ** .5 * parameters.amplitude;\n    }\n}\n\nexport const DEFAULT_SIN_WAVE_UV_PARAMETERS = {\n    amplitude: {default: 2., min: 0., max: 10.},\n    period: {default: 30., min: 10., max: 500.},\n    phaseDelta: {default: .1, min: -10., max: 10.},\n    offset: {default: 0., min: -10., max: 10.},\n    uv: {default: 1, min: 0, max: 1}\n};\n\nexport const DEFAULT_UV_DOT_PARAMETERS = {\n    baseU: {default: 0., min: -100., max: 100.},\n    baseV: {default: 0., min: -100., max: 100.},\n    amplitude: {default: 10., min: -20., max: 20.},\n    uSpacing: {default: 50., min: 0., max: 100.},\n    vSpacing: {default: 50., min: 0., max: 100.},\n    radius: {default: 25., min: 2., max: 50.},\n    radiusScaleV: {default: 1., min: 0., max: 10.},\n    positionShift: {default: 0., min: 0, max: .5},\n    uv: {default: 1, min: 0, max: 1}\n}\n\nexport const DEFAULT_CYLINDER_UV_PARAMETERS = {\n    baseU: {default: 0., min: -100., max: 100.},\n    baseV: {default: 0., min: -100., max: 100.},\n    amplitude: {default: 10., min: -20., max: 20.},\n    height: {default: 30., min: 5., max: 100.},\n    uSpacing: {default: 50., min: 0., max: 100.},\n    vSpacing: {default: 50., min: 0., max: 100.},\n    radiusA: {default: 7.5, min: 2., max: 50.},\n    radiusB: {default: 15., min: 2., max: 50.},\n    positionShift: {default: 0., min: 0, max: .5},\n    uv: {default: 1, min: 0, max: 1}\n}\n\nexport const PATTERN_LIST = {\n    sinWaveUVPattern: {\n        patternParameters: DEFAULT_SIN_WAVE_UV_PARAMETERS,\n        patternFunction: sinWaveUVPattern\n    },\n    dotPyramidUVPattern: {\n        patternParameters: DEFAULT_UV_DOT_PARAMETERS,\n        patternFunction: dotPyramidUVPattern\n    },\n    dotEllipsoidUVPattern: {\n        patternParameters: DEFAULT_UV_DOT_PARAMETERS,\n        patternFunction: dotEllipsoidUVPattern\n    },\n    dotInverseUVPattern: {\n        patternParameters: DEFAULT_UV_DOT_PARAMETERS,\n        patternFunction: dotInverseUVPattern\n    },\n    cylinderUVFunction: {\n        patternParameters: DEFAULT_CYLINDER_UV_PARAMETERS,\n        patternFunction: cylinderUVFunction\n    }\n}\n","import {GeometryFactory} from \"jsts/org/locationtech/jts/geom\";\nimport {ClayPoint} from './clay-point';\nimport {Vector3} from \"three\";\nimport {Polyline} from \"../three/three-poly-line\";\nimport {edgeUVConstraining} from \"./clay-patterns\";\n\nexport class ClayPatternCurve {\n    clayPoints;\n\n    constructor(clayPoints) {\n        this.clayPoints = clayPoints;\n    }\n\n    toPolygon() {\n        let coordinates =[];\n\n        for (const pt of this.clayPoints) {\n            coordinates.push(pt.toCoordinate());\n        }\n\n        coordinates.push(coordinates[0]);\n\n        return new GeometryFactory().createPolygon(coordinates);\n    }\n\n    toPolyline() {\n        let positions = [];\n\n        for (const pt of this.clayPoints) {\n            positions.push(pt.toVector3());\n        }\n\n        return new Polyline(positions);\n    }\n\n    moveToHeight(height = 0.) {\n        for (const pt of this.clayPoints) {\n            pt.z = height;\n        }\n    }\n\n    applyPattern(patternFunction, parameters, easingParameters = null) {\n        if (parameters.uv) {\n            for (const pt of this.clayPoints) {\n                if (easingParameters) {\n                    const edgeValue = edgeUVConstraining(pt.uvValue, easingParameters);\n                    if (edgeValue !== 0.){\n                        pt.set(patternFunction(pt.uvValue, parameters) * edgeValue);\n                    }\n                } else {\n                    pt.set(patternFunction(pt.uvValue, parameters));\n                }\n            }\n        } else {\n            for (const pt of this.clayPoints) {\n                pt.set(patternFunction(pt.origin, parameters));\n            }\n        }\n    }\n\n    toThreePolyline() {\n        let positions = [];\n\n        for (const pt of this.clayPoints) {\n            positions.push(pt.toVector3());\n        }\n\n        return new Polyline(positions);\n    }\n}\n\nexport function testClayCurve(scene = null) {\n    let pts = [\n        new ClayPoint(\n            new Vector3(.5, .5, 0),\n            new Vector3(1, 1, 0),\n        ),\n        new ClayPoint(\n            new Vector3(-.5, .5, 0),\n            new Vector3(-1, 1, 0),\n        ),\n        new ClayPoint(\n            new Vector3(-.5, -.5, 0),\n            new Vector3(-1, -1, 0),\n        ),\n        new ClayPoint(\n            new Vector3(.5, -.5, 0),\n            new Vector3(1, -1, 0),\n        ),\n    ];\n\n    const clayCurve = new ClayPatternCurve(pts);\n\n    if (scene) {\n        // console.log(\"is not null?\");\n        // console.log(scene);\n\n\n\n    } else {\n        console.log(\"is null !!!\");\n    }\n}\n","import {GeometryFactory} from \"jsts/org/locationtech/jts/geom\";\nimport {Path, Vector3} from \"three\";\nimport {Polyline} from \"../three/three-poly-line\";\n\nconst llr = new GeometryFactory().createLinearRing();\n\nfunction getLinearRings(polygon) {\n    let linearRings = [];\n    linearRings.push(polygon.getExteriorRing());\n\n    for (let i = 0; i < polygon.getNumInteriorRing(); i++) {\n        linearRings.push(polygon.getInteriorRingN(i));\n    }\n\n    return linearRings;\n}\n\nfunction vectorFromCoordinate(coordinate) {\n    let locZ;\n\n    if (isNaN(coordinate.z)) {\n        locZ = 0;\n    } else {\n        locZ = coordinate.z;\n    }\n\n    return new Vector3(\n        coordinate.x,\n        locZ,\n        -coordinate.y\n    );\n}\n\nexport function linearRingToPolyline(linearRing) {\n    let vectors = [];\n\n    for (const coordinate of linearRing.getCoordinates()) {\n        vectors.push(vectorFromCoordinate(coordinate) );\n    }\n\n    vectors.pop();\n\n    return new Polyline(vectors);\n}\n\nexport function deconstructPolygon(polygon) {\n    let linearRings = [];\n\n    if (polygon.constructor.name === \"MultiPolygon\") {\n        for (const pg of polygon._geometries) {\n            const llrs = deconstructPolygon(pg);\n            linearRings = linearRings.concat(llrs);\n        }\n\n        return linearRings;\n    }\n\n    const llrs = getLinearRings(polygon);\n    linearRings = linearRings.concat(llrs);\n    return linearRings;\n}\n\nexport function polygonToPolyLines(polygon){\n    let polyLines = [];\n\n    for (const lr of deconstructPolygon(polygon)) {\n        polyLines.push(linearRingToPolyline(lr));\n    }\n\n    return polyLines;\n}\n","import {GeometryFactory} from \"jsts/org/locationtech/jts/geom\";\nimport Coordinate from \"jsts/org/locationtech/jts/geom/Coordinate\";\n\nfunction vector3toCoordinate(vector3) {\n    return new Coordinate(vector3.x, vector3.y, vector3.z);\n}\n\nfunction coordinatesFromPolyline(polyline) {\n    let coordinates = [];\n\n    for (const pt of polyline.points) {\n        coordinates.push(vector3toCoordinate(pt));\n    }\n\n    coordinates.push(coordinates[0]);\n\n    return coordinates;\n}\n\nexport function polylineToPolygon(polyline) {\n    const geoFactory = new GeometryFactory();\n\n    let coordinates = [];\n\n    const polygon = geoFactory.createPolygon(coordinatesFromPolyline(polyline));\n\n    return polygon;\n};","import {PCFShadowMap, WebGL1Renderer, WebGLRenderer} from 'three'\nimport {createHUD} from \"../geometry/three/brick-to-scene\";\n\nexport function getPlanarRenderer() {\n    const renderer = new WebGLRenderer({antialias: true});\n\n    renderer.setClearColor('#cdd0d6');\n    renderer.setPixelRatio(window.devicePixelRatio);\n\n    return renderer;\n}\n\nexport function getPerspectiveRenderer() {\n    const renderer = new WebGL1Renderer({antialias: true, alpha: true})\n\n    // renderer.setClearColor('#ffff99');\n    renderer.setPixelRatio(window.devicePixelRatio);\n\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = PCFShadowMap;\n\n    return renderer;\n}\n\nexport function resize(mount, renderer, camera) {\n    if (!mount || !renderer || !camera)\n        return\n\n    const {clientWidth, clientHeight} = mount.current\n\n    if (camera) {\n        camera.aspect = clientWidth / clientHeight;\n        camera.updateProjectionMatrix();\n    }\n\n    renderer.setSize(clientWidth, clientHeight)\n}\n","import {Scene} from 'three';\nimport {getPerspectiveRenderer, resize} from \"./renderers\";\nimport {getOrbitControls} from \"./orbit-controls\";\nimport {getPerspectiveCamera} from \"./cameras\";\nimport {start, stop} from \"./render-loops\";\nimport {displayPointTest} from \"../geometry/jstsOperations/importing-jsts\";\nimport {addBrick, addLighting} from \"../geometry/three/brick-to-scene\";\n\nexport let scene;\nexport let renderer;\n\nexport function setUp(mount) {\n    scene = new Scene();\n\n    const light = addLighting();\n    scene.add(light);\n\n    addBrick();\n\n    displayPointTest();\n\n    renderer = getPerspectiveRenderer();\n    mount.current.appendChild(renderer.domElement);\n\n    const camera = getPerspectiveCamera(mount.current);\n    scene.add(camera);\n\n    const orbitControls = getOrbitControls(camera, renderer);\n\n    resize(mount, renderer, camera);\n    const frameId = start(renderer, scene, camera);\n\n    return {\n        scene: scene,\n        renderer: renderer,\n        camera: camera,\n        frameId: frameId,\n        orbitControls: orbitControls\n    };\n}\n\nexport function cleanUp(mount, renderer, frameId) {\n    stop(frameId.frameId);\n    mount.current.removeChild(renderer.domElement);\n}\n","export function start(renderer, scene, camera) {\n\n    const frameId = {frameId: null};\n\n    frameId.frameId = requestAnimationFrame(() => animate(renderer, scene, camera, frameId));\n\n    return frameId;\n}\n\nexport function stop({frameId}) {\n    return cancelAnimationFrame(frameId);\n}\n\nfunction animate(renderer, scene, camera, frameId) {\n    renderer.clear('#ddd');\n    renderer.render(scene, camera);\n\n    frameId.frameId = requestAnimationFrame(() => animate(renderer, scene, camera, frameId));\n}\n","import {constructBrick} from \"../clayBrick/clay-simple-base\";\nimport {TubeGeo} from \"../to-three\";\nimport {shaderNormal} from \"../test-geo\";\nimport {DEFAULT_SIN_WAVE_UV_PARAMETERS, sinWaveUVPattern} from \"../clayBrick/clay-patterns\";\nimport {MeshLambertMaterial, TextureLoader, TubeGeometry, Mesh, DirectionalLight} from \"three\";\nimport {scene, renderer} from \"../../three-setup/set-up\";\n\nconst CLAY_TEXTURE_URL = \"https://i.ibb.co/9nk0c8H/terra-cotta-stucco-wall-texture.jpg\";\n\nexport let geometryArray = [];\nexport let overwrites;\n\nexport const OVERWRITE_SETTINGS = {\n    productionWidth: {default: 2.5, min: 1., max: 10.},\n    baseWidth: {default: 150.0, min: 100., max: 200.},\n    baseLength: {default: 300.0, min: 200., max: 400.},\n    lengthBufferMultiplier: {default: 2.0, min: 1.0, max: 10.},\n    pinSpacing: {default: 220.0, min: 100., max: 300.},\n    diamondWidth: {default: 50.0, min: 20., max: 100.},\n    diamondHeight: {default: 110.0, min: 20., max: 200.},\n    diamondCount: {default: 3, min: 1, max: 5},\n    pinDiameter0: {default: 40.0, min: 30., max: 100.},\n    pinDiameter1: {default: 20.0, min: 30., max: 100.},\n    pinDelta: {default: 250.0, min: 1.0, max: 10.},\n    pinDivisions: {default: 60, min: 1.0, max: 10.},\n    precision: {default: 2.0, min: 1.0, max: 10.},\n    bodyHeight: {default: 160.0, min: 1.0, max: 10.},\n    totalHeight: {default: 250.0, min: 1.0, max: 10.},\n    startHeight: {default: -100.0, min: 1.0, max: 10.},\n    layerHeight: {default: 2.5, min: 1.0, max: 10.},\n    easingStart: {default: 20., min: 0., max: 250.},\n    easingEnd: {default: 100., min: 0., max: 250.},\n    pattern: {\n        patternFunction: {default: sinWaveUVPattern},\n        patternParameters: {default: DEFAULT_SIN_WAVE_UV_PARAMETERS}\n    }\n}\n\nfunction overwriteClone() {\n    overwrites = {};\n\n    for (const key in OVERWRITE_SETTINGS) {\n        if (key !== \"pattern\") {\n            overwrites[key] = OVERWRITE_SETTINGS[key].default;\n        } else {\n            overwrites[\"pattern\"] = {\n                patternFunction: OVERWRITE_SETTINGS.pattern.patternFunction.default,\n                patternParameters: patternClone()\n            };\n        }\n    }\n\n    overwrites = updateEasingSettings();\n\n    return overwrites;\n}\n\nfunction patternClone() {\n    let patternSettingsClone = {};\n\n    for (const key in OVERWRITE_SETTINGS.pattern.patternParameters.default) {\n        patternSettingsClone[key] = OVERWRITE_SETTINGS.pattern.patternParameters.default[key].default;\n    }\n\n    return patternSettingsClone;\n}\n\noverwriteClone();\n\nfunction applyBrickShader(scene, pls, parameters) {\n    const loader = new TextureLoader();\n\n    const pipeRadius = parameters.layerHeight * .6;\n\n    loader.load(\n        // resource URL\n        CLAY_TEXTURE_URL,\n\n        // onLoad callback\n        function ( texture ) {\n            // in this example we create the material when the texture is loaded\n            const brickShader = new MeshLambertMaterial( {\n                map: texture\n            } );\n\n            // const brickShader = shaderNormal();\n\n            for (const pl of pls) {\n                const tubeGeo = new TubeGeometry(pl, pl.getPointCount(), pipeRadius, 6, true);\n                const locMesh = new Mesh(tubeGeo, brickShader);\n\n                locMesh.castShadow = true;\n                locMesh.receiveShadow = true;\n\n                geometryArray.push(locMesh);\n\n                scene.add(locMesh);\n            }\n        },\n\n        // onProgress callback currently not supported\n        undefined,\n\n        // onError callback\n        function ( err ) {\n            console.error( 'An error happened.' );\n        }\n    );\n}\n\nexport function addLighting() {\n    const directionalLight = new DirectionalLight( 0xffffff, 1.1 );\n    directionalLight.position.set(500,500,500);\n\n    directionalLight.castShadow = true;\n    directionalLight.shadow.camera.near = 1200;\n    directionalLight.shadow.camera.far = 2500;\n    directionalLight.shadow.bias = 0.0001;\n\n    directionalLight.shadow.mapSize.width = 4096;\n    directionalLight.shadow.mapSize.height = 4096;\n\n    return directionalLight;\n}\n\nfunction totalLength() {\n    return overwrites.baseWidth * Math.PI + (overwrites.baseLength - overwrites.baseWidth) * 2.;\n}\n\nexport function updateEasingSettings() {\n    const locTotalLength = totalLength();\n\n    overwrites.easingParameters = {\n        startLength: overwrites.easingStart,\n        startMaxLength: overwrites.easingEnd,\n        endMaxLength: locTotalLength * .5 - overwrites.easingEnd,\n        endLength: locTotalLength * .5 - overwrites.easingStart,\n        easingDelta: 1. / (overwrites.easingEnd - overwrites.easingStart)\n    };\n\n    return overwrites;\n}\n\nexport function clearScene(scene){\n    for (const obj of geometryArray) {\n        scene.remove(obj);\n        obj.geometry.dispose();\n        obj.material.dispose();\n    }\n\n    console.log(scene);\n\n    geometryArray = [];\n}\n\nexport function addBrick() {\n\n    clearScene(scene);\n\n    updateEasingSettings();\n\n    console.log(overwrites);\n\n    const pls = constructBrick(overwrites)\n\n    applyBrickShader(scene, pls, overwrites);\n}\n","import {OrthographicCamera, PerspectiveCamera} from 'three'\n\nexport function getOrthographicCamera(mount) {\n    const {clientWidth, clientHeight} = mount;\n\n    const camera = new OrthographicCamera(\n        clientWidth / -16,\n        clientWidth /16,\n        clientHeight / 16,\n        clientHeight / -16,\n        -1,\n        100\n    );\n\n    camera.enableRotate = false;\n    camera.position.z = 20;\n\n    return camera;\n}\n\nexport function getPerspectiveCamera(mount) {\n    const {clientWidth, clientHeight} = mount;\n\n    const camera = new PerspectiveCamera(\n        45,\n        clientWidth / clientHeight\n    );\n\n    camera.position.z = 500;\n    return camera;\n}\n","import {MOUSE} from 'three';\nimport {OrbitControls} from \"three/examples/jsm/controls/OrbitControls\";\n\nexport function getOrbitControls(camera, renderer) {\n    const orbitControls = new OrbitControls(camera, renderer.domElement);\n    orbitControls.enableRotate = true;\n    orbitControls.enableKeys = true;\n    // orbitControls.minZoom = .5;\n    // orbitControls.maxZoom = 8;\n    // orbitControls.mouseButtons = {ZOOM: MOUSE.MIDDLE, PAN: MOUSE.RIGHT};\n\n    orbitControls.target.set(0, 0);\n    orbitControls.update();\n\n    return orbitControls;\n}\n\n","import {deconstructPolygon} from \"../jsts2Three/jsts-to-three\";\nimport {Coordinate, GeometryFactory} from \"jsts/org/locationtech/jts/geom\";\nimport BufferOp from \"jsts/org/locationtech/jts/operation/buffer/BufferOp\";\n\nimport \"jsts/org/locationtech/jts/monkey.js\";\nimport {geometryArray} from \"../three/brick-to-scene\";\nimport {LineMerger} from \"jsts/org/locationtech/jts/operation/linemerge\";\n\nconst geoFactory = new GeometryFactory();\n\nfunction splitLineStringWithPoint(lineString, coordinate = null, radius) {\n    const circle = creatCircle(coordinate.x, coordinate.y, radius);\n\n    let mls = lineString.difference(circle);\n\n    let lrs = joinLineStrings(mls);\n\n    return lrs;\n}\n\nfunction createPoint(x, y){\n    const coord = new Coordinate(x, y);\n    return geoFactory.createPoint(coord);\n}\n\nfunction createBuffer(geom, radius, segments = 32) {\n    return BufferOp.bufferOp(geom, radius, segments);\n}\n\nfunction creatCircle(x, y, radius) {\n    const point = createPoint(x, y);\n\n    return createBuffer(point, radius, 100);\n}\n\nfunction reverseAJoinB(linestringA, linestringB) {\n    let coords = linestringB.getCoordinates();\n\n    coords = coords.concat(linestringA.reverse().getCoordinates());\n    coords.push(coords[0]);\n\n    return geoFactory.createLineString(coords);\n}\n\nfunction getEnvelopes(lrA, lrB) {\n    return {\n        bboxA: lrA.getEnvelopeInternal(),\n        bboxB: lrB.getEnvelopeInternal()\n    }\n}\n\nconst switchingFunctionMap = {\n    top: checkTop,\n    bottom: checkBottom,\n    left: checkLeft,\n    right: checkRight,\n    small: checkSmaller,\n    large: checkLarger\n}\n\nfunction sameOrder(lrA, lrB) {\n    return {lrA: lrA, lrB: lrB};\n}\n\nfunction inverseOrder(lrA, lrB) {\n    return {lrA: lrB, lrB: lrA};\n}\n\nfunction checkFunction(functionName, lrA, lrB) {\n    if (switchingFunctionMap[functionName](lrA, lrB)) {\n        return sameOrder(lrA, lrB);\n    } else {\n        return inverseOrder(lrA, lrB);\n    }\n}\n\nfunction sortGeometries(functionName, lrs){\n    function sortForThis(lrA, lrB) {\n        if (switchingFunctionMap[functionName](lrA, lrB)) {\n            return 1;\n        } else {\n            return -1;\n        }\n    }\n    lrs.sort(sortForThis);\n    return lrs;\n}\n\nfunction checkSmaller(lrA, lrB) {\n    const {bboxA, bboxB} = getEnvelopes(lrA, lrB);\n    return bboxA.getArea() < bboxB.getArea();\n}\n\nfunction checkLarger(lrA, lrB) {\n    const {bboxA, bboxB} = getEnvelopes(lrA, lrB);\n    return bboxA.getArea() > bboxB.getArea();\n}\n\nfunction checkLeft(lrA, lrB) {\n    const {bboxA, bboxB} = getEnvelopes(lrA, lrB);\n    return bboxA.getMaxX() < bboxB.getMinX();\n}\n\nfunction checkRight(lrA, lrB) {\n    const {bboxA, bboxB} = getEnvelopes(lrA, lrB);\n    return bboxB.getMaxX() < bboxA.getMinX();\n}\n\nfunction checkTop(lrA, lrB) {\n    const {bboxA, bboxB} = getEnvelopes(lrA, lrB);\n    return bboxA.getMaxY() < bboxB.getMinY();\n}\n\nfunction checkBottom(lrA, lrB) {\n    const {bboxA, bboxB} = getEnvelopes(lrA, lrB);\n    return bboxB.getMaxY() < bboxA.getMinY();\n}\n\nfunction deconstructMultiLineString(mls) {\n    let linearRings = [];\n    for (let i = 0; i < mls.getNumGeometries(); i++) {\n        linearRings.push(mls.getGeometryN(i));\n    }\n\n    return linearRings;\n}\n\nfunction mergeTouchingLineStrings(lrA, lrB) {\n    let coords = lrA.getCoordinates();\n    coords.pop();\n    coords = coords.concat(lrB.getCoordinates());\n\n    return geoFactory.createLineString(coords);\n}\n\nfunction joinLineStrings(mls) {\n    const lrs = deconstructMultiLineString(mls);\n\n    let hasBeenJoined = [];\n    let joinedLrs = [];\n\n    for (const lr of lrs) {\n        if (!hasBeenJoined.includes(lr)){\n            for (const locLr of lrs) {\n                if ( (lr !== locLr) & (!hasBeenJoined.includes(locLr) ) ) {\n                    const endPoint = lr.getEndPoint().getCoordinate();\n                    const startPoint = locLr.getStartPoint().getCoordinate();\n\n                    if (endPoint.distance(startPoint) < .001) {\n                        joinedLrs.push(mergeTouchingLineStrings(lr, locLr));\n                        hasBeenJoined.push(locLr);\n                        hasBeenJoined.push(lr);\n                    }\n                }\n            }\n        }\n    }\n\n    for (const lr of lrs) {\n        if (!hasBeenJoined.includes(lr)) {\n            joinedLrs.push(lr);\n        }\n    }\n\n    return joinedLrs;\n}\n\nfunction concatenateLineStrings(lrs){\n    let coords = [];\n\n    for (const lr of lrs){\n        coords = coords.concat(lr.getCoordinates());\n    }\n\n    coords.push(coords[0]);\n    return geoFactory.createLinearRing(coords);\n}\n\nfunction hardcodedTweaking(polygon, coords, radius){\n    let resultLrs = [];\n    let intermediateLrs;\n    let activeLr;\n\n    intermediateLrs = splitLineStringWithPoint(polygon, coords.a.v0, radius)\n    if (intermediateLrs.length === 2) {\n        let lr0 = intermediateLrs[0];\n        let lr1 = intermediateLrs[1];\n\n        let {lrA, lrB} = checkFunction(\"large\", lr0, lr1);\n\n        resultLrs.push(lrA);\n\n        lrB = lrB.reverse();\n        activeLr = lrB;\n    }\n\n    intermediateLrs = splitLineStringWithPoint(activeLr, coords.a.v1, radius)\n    if (intermediateLrs.length === 3) {\n        intermediateLrs = sortGeometries(\"small\", intermediateLrs);\n        let lr0 = intermediateLrs[1];\n        let lr1 = intermediateLrs[2];\n\n        let {lrA, lrB} = checkFunction(\"bottom\", lr0, lr1);\n\n        resultLrs.push(lrB);\n        lrA = lrA.reverse()\n        resultLrs.push(lrA);\n\n        activeLr = intermediateLrs[0];\n    }\n\n    intermediateLrs = splitLineStringWithPoint(activeLr, coords.a.v2, radius)\n    if (intermediateLrs.length === 3) {\n        intermediateLrs = sortGeometries(\"large\", intermediateLrs);\n        let lr0 = intermediateLrs[0];\n        let lr1 = intermediateLrs[1];\n\n        let {lrA, lrB} = checkFunction(\"bottom\", lr0, lr1);\n        resultLrs.push(lrA);\n\n        let subIntermediate = splitLineStringWithPoint(lrB, coords.a.v3, radius);\n        if (subIntermediate.length === 3) {\n            subIntermediate = sortGeometries(\"bottom\", subIntermediate);\n            let lr0 = subIntermediate[2];\n            let lr1 = subIntermediate[1];\n\n            const output = checkFunction(\"left\", lr0, lr1);\n\n            resultLrs = [\n                output.lrB,\n                subIntermediate[0].reverse(),\n                output.lrA\n            ].concat(resultLrs);\n        }\n\n        activeLr = intermediateLrs[2].reverse();\n    }\n\n    let count = 0;\n\n    for (const diamondC of coords.d) {\n        intermediateLrs = splitLineStringWithPoint(activeLr,diamondC, radius);\n\n        if (intermediateLrs.length === 3) {\n            intermediateLrs = sortGeometries(\"right\", intermediateLrs);\n\n            let lr0 = intermediateLrs[0];\n            let lr1 = intermediateLrs[1];\n\n            let locFunctionName;\n            if (count % 2 === 0) {\n                locFunctionName = \"bottom\";\n            } else {\n                locFunctionName = \"top\";\n            }\n            let {lrA, lrB} = checkFunction(locFunctionName, lr0, lr1);\n\n            resultLrs = [lrA].concat(resultLrs);\n            resultLrs.push(lrB);\n\n            activeLr = intermediateLrs[2].reverse();\n        }\n        count++;\n    }\n\n    intermediateLrs = splitLineStringWithPoint(activeLr, coords.b.v0, radius)\n    if (intermediateLrs.length === 3) {\n        intermediateLrs = sortGeometries(\"right\", intermediateLrs);\n\n        let lr0 = intermediateLrs[0];\n        let lr1 = intermediateLrs[1];\n\n        let {lrA, lrB} = checkFunction(\"bottom\", lr0, lr1);\n\n        resultLrs = [lrA].concat(resultLrs);\n        resultLrs.push(lrB);\n\n        activeLr = intermediateLrs[2].reverse();\n    }\n\n    if (count % 2 === 1) {\n        activeLr = activeLr.reverse();\n    }\n\n    intermediateLrs = splitLineStringWithPoint(activeLr, coords.b.v2, radius)\n    if (intermediateLrs.length === 3) {\n        intermediateLrs = sortGeometries(\"left\", intermediateLrs);\n        let lr0 = intermediateLrs[1];\n        let lr1 = intermediateLrs[2];\n\n        let localResults = [];\n\n        let {lrA, lrB} = checkFunction(\"bottom\", lr0, lr1);\n\n        let subIntermediate = splitLineStringWithPoint(lrA, coords.b.v1, radius);\n        if (subIntermediate.length === 3) {\n            subIntermediate = sortGeometries(\"top\", subIntermediate);\n            let lr0 = subIntermediate[2];\n            let lr1 = subIntermediate[1];\n\n            const output = checkFunction(\"left\", lr0, lr1);\n\n            localResults = [\n                output.lrA,\n                subIntermediate[0].reverse(),\n                output.lrB\n            ];\n        }\n\n        localResults.push(intermediateLrs[0].reverse());\n\n        subIntermediate = splitLineStringWithPoint(lrB, coords.b.v3, radius);\n        if (subIntermediate.length === 3) {\n            subIntermediate = sortGeometries(\"bottom\", subIntermediate);\n            let lr0 = subIntermediate[2];\n            let lr1 = subIntermediate[1];\n\n            const output = checkFunction(\"right\", lr0, lr1);\n\n            localResults = localResults.concat([\n                output.lrA,\n                subIntermediate[0].reverse(),\n                output.lrB\n            ]);\n        }\n\n        if (count % 2 === 1) {\n            let flippedCurves = [];\n            localResults.reverse();\n            for (const lr of localResults){\n                flippedCurves.push(lr.reverse());\n            }\n            localResults = flippedCurves;\n        }\n\n        resultLrs = resultLrs.concat(localResults);\n\n    }\n\n    return concatenateLineStrings(resultLrs);\n}\n\nexport function twistIntersect(polygon, coords = [], p = null) {\n    const linearRings = deconstructPolygon(polygon);\n\n    const radius = (p.productionWidth * .5) * 1.415;\n\n    if (linearRings.length === 1) {\n        let activeLR = linearRings[0];\n\n        return [hardcodedTweaking(activeLR, coords, radius)];\n\n    } else {\n        // console.log(\"this slice contains more than one more line string\");\n        return null;\n    }\n}\n","// defining base parameters\n// all lengths are in mm\n// base height, width\n\nimport {ClayPatternCurve} from \"./clay-pattern-curve\";\nimport {Polyline} from \"../three/three-poly-line\";\nimport {ClayPoint} from \"./clay-point\";\nimport {polylineToPolygon} from \"../jsts2Three/three-to-jsts\";\nimport {createBuffer, geometriesDifference, geometriesIntersection, geometryUnion} from \"../jstsOperations/importing-jsts\";\nimport {deconstructPolygon, linearRingToPolyline, polygonToPolyLines} from \"../jsts2Three/jsts-to-three\";\nimport {Vector2, Vector3} from \"three\";\nimport {twistIntersect} from \"../jstsOperations/deconstruct-polygon\";\n\nfunction pinDiameterAtHeight(p, height) {\n    return p.pinDiameterDelta * height + p.pinDiameter0;\n}\n\nfunction arcClayPt(i, startPhase, angleDelta, radius, basePoint, vVal = 0.) {\n    const baseAngle = angleDelta * i;\n    const angle = startPhase + baseAngle;\n\n    const x0 = Math.cos(angle);\n    const y0 = Math.sin(angle);\n\n    const x = radius * x0;\n    const y = radius * y0;\n\n    const clayPoint = new ClayPoint(\n        new Vector3(basePoint.x + x, basePoint.y + y, basePoint.z),\n        new Vector3(x0, y0, 0)\n    );\n\n    clayPoint.uvValue = new Vector2(vVal + baseAngle * radius, basePoint.z);\n\n    return clayPoint\n}\n\nfunction arcDivisions(radius, goalLength, arcAngle, startPhase, basePoint, clayPoints, vVal = 0.) {\n    const count = Math.ceil(arcAngle * radius / goalLength);\n    const angleDelta = arcAngle / count;\n\n    for (let i = 0; i < count; i++) {\n        const clayPoint = arcClayPt(i, startPhase, angleDelta, radius, basePoint, vVal);\n        clayPoints.push(clayPoint);\n    }\n\n    return arcAngle * radius + vVal;\n}\n\nfunction lineDivisions(v0, v1, goalLength, clayPoints, vVal = 0.) {\n    const length = v0.distanceTo(v1);\n    const count = Math.ceil( length / goalLength);\n\n    const delta = new Vector3().addScaledVector(\n        new Vector3().subVectors(v1, v0),\n        1. / count\n    );\n\n    const deltaLength = delta.length();\n\n    const normal = new Vector3(delta.y / deltaLength, -delta.x / deltaLength);\n\n    for (let i = 0; i < count; i++) {\n        const v = new Vector3().addVectors(\n            v0,\n            new Vector3().addScaledVector(delta, i)\n        );\n\n        const clayPoint = new ClayPoint(v, normal);\n        clayPoint.uvValue = new Vector2(vVal + i * deltaLength, v0.z);\n        clayPoints.push(clayPoint);\n    }\n\n    return length + vVal;\n}\n\nexport function outerProfile(p, height = 0.) {\n    const v0 = new Vector3(-(p.baseLength - p.baseWidth) * .5, 0.0, height);\n    const v1 = new Vector3((p.baseLength - p.baseWidth) * .5, 0.0, height);\n\n    let clayPoints = [];\n\n    let vVal = 0.;\n\n    vVal = arcDivisions(p.baseWidth * .5, p.precision, .5 * Math.PI, Math.PI, v0, clayPoints, vVal);\n\n    const p0 = new Vector3(-(p.baseLength - p.baseWidth) * .5, -p.baseWidth * .5, height);\n    const p1 = new Vector3((p.baseLength - p.baseWidth) * .5, -p.baseWidth * .5, height);\n\n    vVal = lineDivisions(p0, p1, p.precision, clayPoints, vVal);\n\n    vVal = arcDivisions(p.baseWidth * .5, p.precision, Math.PI, -.5 *Math.PI, v1, clayPoints, vVal);\n\n    const p2 = new Vector3((p.baseLength - p.baseWidth) * .5, p.baseWidth * .5, height);\n    const p3 = new Vector3(-(p.baseLength - p.baseWidth) * .5, p.baseWidth * .5, height);\n\n    vVal = lineDivisions(p2, p3, p.precision, clayPoints, vVal);\n\n    arcDivisions(p.baseWidth * .5, p.precision, .5 * Math.PI, .5 * Math.PI, v0, clayPoints, vVal);\n\n    const clayPolyline = new ClayPatternCurve(clayPoints);\n\n    return clayPolyline;\n}\n\nfunction simpleLineDivison(v0, v1, divisions, withEnds = false, relativeShift = null) {\n    const delta = new Vector3().addScaledVector(\n        new Vector3().subVectors(v1, v0),\n        1. / divisions\n    );\n\n    let vs = [];\n\n    let start = 0;\n    let end = divisions + 1;\n\n    if (!withEnds) {\n        start = 1;\n        end = divisions;\n    }\n\n    if (!(relativeShift === null)) {\n        start += relativeShift;\n        end += relativeShift;\n    }\n\n    for (let i = start; i < end; i++) {\n        const v = new Vector3().addVectors(\n            v0,\n            new Vector3().addScaledVector(delta, i)\n        );\n\n        vs.push(v);\n    }\n\n    return vs;\n}\n\nfunction simpleArcDivision(baseV, radius, arcAngle = Math.PI, startPhase = 0., division = 100) {\n    const delta = arcAngle / division;\n\n    let vs = [];\n\n    for (let i = 0; i < division; i++) {\n        const angle = startPhase + i * delta;\n\n        const x = radius * Math.cos(angle);\n        const y = radius * Math.sin(angle);\n\n        vs.push(new Vector3(baseV.x + x, baseV.y + y, 0));\n    }\n\n    return new Polyline(vs);\n}\n\nfunction diamondPolyline(p, bPoint) {\n    return new Polyline([\n        new Vector3(bPoint.x + p.diamondWidth * .5, bPoint.y, 0),\n        new Vector3(bPoint.x, bPoint.y + p.diamondHeight * .5, 0),\n        new Vector3(bPoint.x - p.diamondWidth * .5, bPoint.y, 0),\n        new Vector3(bPoint.x, bPoint.y - p.diamondHeight * .5, 0)\n    ]);\n}\n\nfunction rectangle(bPoint, width, height) {\n    return new Polyline([\n        new Vector3(bPoint.x + width * .5, bPoint.y + .5 * height, 0),\n        new Vector3(bPoint.x - width * .5, bPoint.y + .5 * height, 0),\n        new Vector3(bPoint.x - width * .5, bPoint.y - .5 *  height, 0),\n        new Vector3(bPoint.x + width * .5, bPoint.y - .5 *  height, 0)\n    ]);\n}\n\nexport function innerProfileGeom(v0, v1, p, height = 0., pinR = 10.) {\n\n    const diamondVs = simpleLineDivison(v0, v1, p.diamondCount + 1, false);\n\n    let pls = [];\n\n    for (const diamondV of diamondVs) {\n        const diamond = diamondPolyline(p, diamondV);\n        const diamondRect = rectangle(diamondV, p.productionWidth, p.baseWidth * p.lengthBufferMultiplier);\n\n        pls.push(diamond);\n        pls.push(diamondRect);\n    }\n\n    pls.push(simpleArcDivision(v0, pinR, 2. * Math.PI, 0., p.pinDivisions));\n    pls.push(simpleArcDivision(v1, pinR, 2. * Math.PI, 0., p.pinDivisions));\n    pls.push(rectangle(v0, p.productionWidth, p.baseWidth * p.lengthBufferMultiplier));\n    pls.push(rectangle(v1, p.productionWidth, p.baseWidth * p.lengthBufferMultiplier));\n    pls.push(rectangle(new Vector3(0, 0, 0),p.baseLength + p.baseWidth * (p.lengthBufferMultiplier - 1.), p.productionWidth));\n\n    let polygons = [];\n    for (const pl of pls){\n        polygons.push(polylineToPolygon(pl));\n    }\n\n    const geom = geometryUnion(polygons);\n\n    return geom;\n}\n\nexport function innerProfile(v0, v1, p, height = 0., pinR = 10.) {\n    const geom = innerProfileGeom(v0, v1, p, height, pinR);\n\n    const polylines = polygonToPolyLines(geom);\n\n    for (const pl of polylines) {\n        pl.moveToHeight(height);\n    }\n\n    return polylines;\n}\n\nfunction generateCrossPin(v, pinR, p) {\n    const spacing = pinR + p.productionWidth * .5;\n\n    return {\n        v0: {\n            x: v.x - spacing,\n            y: v.y\n        },\n        v1: {\n            x: v.x,\n            y: v.y + spacing\n        },\n        v2: {\n            x: v.x + spacing,\n            y: v.y\n        },\n        v3: {\n            x: v.x,\n            y: v.y - spacing\n        }\n    }\n}\n\nexport function aSlice(v0, v1, p, height = 0.) {\n    const outerClayCurve = outerProfile(p, height);\n\n    outerClayCurve.applyPattern(\n        p.pattern.patternFunction,\n        p.pattern.patternParameters,\n        p.easingParameters\n    );\n\n    const outerGeom = outerClayCurve.toPolygon();\n\n    const bufferedOuterGeom = createBuffer(outerGeom, -p.productionWidth, 1);\n\n    const recL = (p.baseLength + p.baseWidth * (p.lengthBufferMultiplier - 1.)) * .5;\n\n    const leftRec = rectangle(\n        new Vector3(-recL * .5, 0, 0),\n        recL,\n        p.productionWidth\n    );\n\n    const leftRecPg = polylineToPolygon(leftRec);\n    const unionOuterGeom = geometryUnion([bufferedOuterGeom, leftRecPg])\n\n    const pinR = pinDiameterAtHeight(p, height) * .5;\n\n    const innerGeom = innerProfileGeom(v0, v1, p, height, pinR);\n\n    const geom = geometriesIntersection(unionOuterGeom, innerGeom);\n\n    const path = geometriesDifference(outerGeom, geom)\n\n    let diamondCrosses = simpleLineDivison(v0, v1, p.diamondCount + 1, false, .5);\n\n    diamondCrosses.pop();\n    // diamondCrosses = diamondCrosses.reverse();\n\n    const coords = {\n        a: generateCrossPin(v0, pinR, p),\n        b: generateCrossPin(v1, pinR, p),\n        d: diamondCrosses\n    }\n\n    const lineStrings = twistIntersect(path, coords, p);\n\n    let polyLines = [];\n    let coordinateLists = [];\n\n    for (const lr of lineStrings) {\n        polyLines.push(linearRingToPolyline(lr));\n        for (const coordinate of lr.getCoordinates()) {\n            coordinateLists.push([coordinate.x, coordinate.y, height])\n        }\n    }\n\n    return {polyLines: polyLines, coordinateLists: coordinateLists};\n}\n\nfunction aPinOnlySlice(v0, v1, p, height) {\n    let pls = [];\n\n    const pinDiameter = pinDiameterAtHeight(p, height);\n\n    const arcA = simpleArcDivision(v0, pinDiameter * .5, 2. * Math.PI, 0., p.pinDivisions);\n    const arcB = simpleArcDivision(v1, pinDiameter * .5, 2. * Math.PI, 0., p.pinDivisions);\n\n    arcA.cadFlip();\n    arcB.cadFlip();\n\n    pls.push(arcA);\n    pls.push(arcB);\n\n    return pls;\n}\n\nexport function constructBrick(p) {\n    const v0 = new Vector3(-p.pinSpacing * .5, 0.0);\n    const v1 = new Vector3(p.pinSpacing * .5, 0.0);\n\n    p.pinDiameterDelta = (p.pinDiameter1 - p.pinDiameter0) / p.pinDelta;\n\n    let polylines = [];\n\n    let coordinatListss = []\n\n    let localH = 0.;\n    for (localH; localH < p.bodyHeight; localH += p.layerHeight) {\n        const {polyLines, coordinateLists} = aSlice(v0, v1, p, localH);\n        coordinatListss = coordinatListss.concat(coordinateLists);\n        for (const pl of polyLines) {\n\n            pl.moveToHeight(localH + p.startHeight);\n            polylines.push(pl);\n        }\n    }\n\n    for (localH; localH < p.totalHeight; localH += p.layerHeight) {\n        for (const pl of aPinOnlySlice(v0, v1, p, localH)) {\n            pl.moveToHeight(localH + p.startHeight);\n            polylines.push(pl);\n        }\n    }\n\n    window.coordinates = coordinatListss;\n\n    return polylines;\n}\n\n","import {GUI} from \"three/examples/jsm/libs/dat.gui.module\";\nimport {USDZExporter} from \"three/examples/jsm/exporters/USDZExporter\";\nimport {\n    addBrick,\n    clearScene,\n    OVERWRITE_SETTINGS,\n    overwrites,\n    updateEasingSettings\n} from \"../geometry/three/brick-to-scene\";\nimport {PATTERN_LIST} from \"../geometry/clayBrick/clay-patterns\";\nimport {outputCSV} from \"../geometry/io/export-to-csv\";\n\nexport function createGUI(scene) {\n    const gui = new GUI({ autoPlace: true, width: 150 });\n\n    for (const patternName in PATTERN_LIST) {\n        const localPatternGUI = gui.addFolder(patternName);\n\n        for (const patternParameter in PATTERN_LIST[patternName].patternParameters) {\n\n            addPatternOverwrites(localPatternGUI, patternParameter, patternName);\n        }\n    }\n\n    const defaultParameters = gui.addFolder(\"constructionParameters\");\n\n    for (const overwriteName in overwrites) {\n        if (overwriteName !== \"pattern\" && OVERWRITE_SETTINGS.hasOwnProperty(overwriteName)) {\n            addAllOverwrites(defaultParameters, overwriteName);\n        }\n    }\n\n    let obj = { download:function(){ addCSVOutput() }};\n\n    gui.add(obj, \"download\");\n}\n\nfunction addCSVOutput() {\n    let encodedUri = encodeURI(outputCSV());\n    let link = document.createElement(\"a\");\n    link.setAttribute(\"href\", encodedUri);\n    link.setAttribute(\"download\", \"my_data.csv\");\n    document.body.appendChild(link); // Required for FF\n\n    link.click(); // This will download the data file named \"my_data.csv\".\n}\n\nfunction addAllOverwrites(guiElement, overwriteElement) {\n    guiElement.add(\n        overwrites,\n        overwriteElement,\n        overwrites[overwriteElement].min,\n        overwrites[overwriteElement].max\n    ).onChange(function (value) {\n        overwrites[overwriteElement] = value;\n        // updateEasingSettings();\n\n        addBrick();\n    });\n}\n\nfunction addPatternOverwrites(guiElement, overwritePatternElement, patternName) {\n\n    const patternParameters = PATTERN_LIST[patternName].patternParameters;\n\n    overwrites.pattern.patternParameters[overwritePatternElement] = patternParameters[overwritePatternElement].default;\n\n    const slider = guiElement.add(\n        overwrites.pattern.patternParameters,\n        overwritePatternElement,\n        patternParameters[overwritePatternElement].min,\n        patternParameters[overwritePatternElement].max\n    );\n\n    slider.onChange(function (value) {\n        overwrites.pattern.patternFunction = PATTERN_LIST[patternName].patternFunction;\n        overwrites.pattern.patternParameters[overwritePatternElement] = value;\n        // updateEasingSettings();\n\n        addBrick();\n    });\n}\n","export function outputCSV() {\n    let csvContent = \"data:text/csv;charset=utf-8,\";\n\n    for (const entry of window.coordinates) {\n        csvContent += entry.toString() + \"\\r\\n\";\n    };\n\n    return csvContent;\n}\n","import React, {useEffect, useRef} from 'react';\nimport Measure from 'react-measure';\nimport {cleanUp, setUp} from \"./three-setup/set-up\";\nimport {resize} from \"./three-setup/renderers\";\nimport {GUI} from 'three/examples/jsm/libs/dat.gui.module';\nimport {createGUI} from \"./three-setup/gui-setup\";\n\nimport './Viewer.scss';\n\nfunction Viewer() {\n    const mount = useRef(null);\n    const rendererRef = useRef(null);\n    const cameraRef = useRef(null);\n\n    let gui;\n\n\n    useEffect(() => {\n        console.log(mount);\n\n        const {scene, camera, renderer, frameId} = setUp(mount);\n\n        rendererRef.current = renderer;\n        cameraRef.current = camera;\n\n        gui = createGUI(scene);\n\n        return () => {\n            cleanUp(mount, renderer, frameId);\n        }\n    }, [rendererRef, cameraRef]);\n\n    return (\n        <Measure\n            bounds\n            onResize={() => {\n                resize(mount, rendererRef.current, cameraRef.current)\n            }}>\n            {({measureRef}) => (\n                <div className={'simple-3d'} ref={measureRef}>\n                    <div className={'three-canvas'} ref={mount} tabIndex={0}/>\n                </div>\n            )}\n        </Measure>\n    )\n}\n\nexport default Viewer;\n","// ... App.js\nimport React, {Component} from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as THREE from \"three\";\nimport {TestGeo} from \"./geometry/test-geo\";\nimport {setUp} from \"./three-setup/set-up\";\n\nimport './App.css';\nimport Viewer from \"./Viewer\";\n\nfunction App() {\n    return (\n        <div className={'app'}>\n            <div className={'container'}>\n                <Viewer/>\n            </div>\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}