{"version":3,"sources":["geometry/to-three.js","geometry/shaders-materials.js","geometry/importing-jsts.js","geometry/three/three-poly-line.js","geometry/clayBrick/clay-pattern-curve.js","geometry/jsts2Three/jsts-to-three.js","geometry/jsts2Three/three-to-jsts.js","geometry/clayBrick/clay-simple-base.js","geometry/test-geo.js","three-setup/renderers.js","three-setup/render-loops.js","three-setup/set-up.js","three-setup/cameras.js","three-setup/orbit-controls.js","Viewer.js","three-setup/gui-setup.js","App.js","reportWebVitals.js","index.js","geometry/clayBrick/clay-point.js"],"names":["TubeGeo","path","segs","radius","radSegs","closed","material","geo","TubeGeometry","Mesh","shaders","vertexShader","fragmentShader","transparent","uniforms","extensions","derivatives","triangulationFromPolygon","polygon","builder","DelaunayTriangulationBuilder","setSites","setTolerance","getTriangles","GeometryFactory","edgesFromTriangulation","triangulation","vertexDict","vPairs","pureVertices","boundary","_geometries","coords","getGeometryN","getCoordinates","length","cMap","idx","coor","coordinate","JSON","stringify","x","y","z","dictCount","Object","keys","Vector3","a","b","v0","Math","min","v1","max","idxVertex","v","lines","localLineCurve","LineCurve","push","bufferFromTriangulation","bufferGeo","BufferGeometry","coordinatesList","vertices","Float32Array","setAttribute","BufferAttribute","computeVertexNormals","createBuffer","geom","segments","BufferOp","bufferOp","geometriesIntersection","geosA","geosB","intersection","geometryUnion","geos","collection","createGeometryCollection","union","geometriesUnion","UnaryUnionOp","multiplePoints","strings","reader","WKTReader","aString","read","readWKString","bufferedGeos","displayPointTest","plg","buffer","edges","triangulatePolyline","CustomSinCurve","scale","t","optionalTarget","tx","ty","sin","PI","tz","set","multiplyScalar","this","Curve","Polyline","points","init","dirs","getDirs","arcLengthDivisions","getPointCount","dirList","i","vDir","subVectors","lengths","getLengths","cacheArcLengths","needsUpdate","previous","u","getTangent","vT","locT","roundT","isNaN","copy","normalize","addVectors","normal","tangents","normals","binormals","vec","mat","Matrix4","getTangentAt","Number","MAX_VALUE","abs","crossVectors","clone","EPSILON","theta","acos","clamp","dot","applyMatrix4","makeRotationAxis","t0","getPoint","_tConstraining","addScaledVector","height","point","periods","amplitude","step","phase","ClayPatternCurve","clayPoints","coordinates","pt","toCoordinate","createPolygon","positions","toVector3","createLinearRing","vectorFromCoordinate","locZ","linearRingToPolyline","linearRing","vectors","pop","polygonToPolylines","polylines","constructor","name","pg","pl","lrs","linearRings","getExteriorRing","getNumInteriorRing","getInteriorRingN","getLinearRings","lr","polylineToPolygon","polyline","vector3","Coordinate","coordinatesFromPolyline","require","ClayPoint","pinRadiusAtHeight","arcDivisions","goalLength","arcAngle","startPhase","basePoint","count","ceil","angleDelta","angle","x0","cos","y0","lineDivisions","distanceTo","delta","outerProfile","baseWidth","p0","p1","p2","p3","clayPolyline","simpleLineDivison","divisions","withEnds","vs","start","end","simpleArcDivision","baseV","division","diamondPolyline","bPoint","diamondWidth","diamondHeight","rectangle","width","innerProfileGeom","pinSpacing","diamondVs","diamondCount","pls","diamondV","diamond","diamondRect","pinDiameter","baseLength","polygons","aSlice","outerClayCurve","outerGeom","toPolygon","bufferedOuterGeom","innerGeom","moveToHeight","shaderMaterialEdges","ShaderMaterial","geoTubeTest","blWhiteShader","tubes","makeMeWave","addTestGeos","scene","add","testTube","locTubeGeo","clayPointTest","pts","console","log","testClayCurve","tube","resize","mount","renderer","camera","current","clientWidth","clientHeight","aspect","updateProjectionMatrix","setSize","frameId","requestAnimationFrame","animate","clear","render","setUp","Scene","WebGL1Renderer","antialias","alpha","setClearColor","setPixelRatio","window","devicePixelRatio","getPerspectiveRenderer","appendChild","domElement","PerspectiveCamera","position","getPerspectiveCamera","orbitControls","OrbitControls","enableRotate","enableKeys","target","update","getOrbitControls","cleanUp","cancelAnimationFrame","stop","removeChild","Viewer","useRef","rendererRef","cameraRef","useEffect","gui","GUI","exportUSDZ","usdz","createGUI","bounds","onResize","measureRef","className","ref","tabIndex","App","id","rel","href","download","src","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById","origin","direction","value","vBase","clayPoint","move"],"mappings":"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","file":"static/js/main.d809cb78.chunk.js","sourcesContent":["import {\n    Mesh,\n    TubeGeometry\n} from \"three\";\n\nexport function TubeGeo(path, segs, radius, radSegs, closed, material) {\n    const geo = new TubeGeometry(path, segs, radius, radSegs, closed);\n    return new Mesh(geo, material);\n}\n","export const shaders = {\n    normalShader: {\n        vertexShader: `\n            varying vec3 v_Normal;\n            void main() {\n                v_Normal = normal;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            varying vec3 v_Normal;\n            void main() {\n                gl_FragColor = vec4(v_Normal * .8, .8);\n                // vec3 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);\n    \n            }`,\n        transparent: true,\n        uniforms: {}\n    },\n\n    smokeShader: {\n        fragmentShader: `\n            uniform vec2 res;\n            uniform sampler2D bufferTexture;\n            uniform vec3 smokeSource;\n            \n            void main() {\n                vec2 pixel = gl_FragCoord.xy / res.xy;\n                gl_FragColor = texture2D( bufferTexture, pixel );\n            \n                //Get the distance of the current pixel from the smoke source\n                float dist = distance(smokeSource.xy,gl_FragCoord.xy);\n                //Generate smoke when mouse is pressed\n                gl_FragColor.rgb += smokeSource.z * max(15.0-dist,0.0);\n            \n                //Smoke diffuse\n                float xPixel = 1.0/res.x;//The size of a single pixel\n                float yPixel = 1.0/res.y;\n                vec4 rightColor = texture2D(bufferTexture,vec2(pixel.x+xPixel,pixel.y));\n                vec4 leftColor = texture2D(bufferTexture,vec2(pixel.x-xPixel,pixel.y));\n                vec4 upColor = texture2D(bufferTexture,vec2(pixel.x,pixel.y+yPixel));\n                vec4 downColor = texture2D(bufferTexture,vec2(pixel.x,pixel.y-yPixel));\n                //Diffuse equation\n                gl_FragColor.rgb += 14.0 * 0.016 * (leftColor.rgb + rightColor.rgb + downColor.rgb + upColor.rgb - 4.0 * gl_FragColor.rgb);\n            }`\n    },\n\n    gridNormal: {\n        vertexShader: `\n            varying vec3 v_Position;\n            varying vec3 v_Normal;\n            void main() {\n                v_Position = position;\n                v_Normal = normal;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            varying vec3 v_Position;\n            varying vec3 v_Normal;\n            void main() {\n                vec3 grid = abs(fract(v_Position - 0.5) - 0.5) / fwidth(v_Position);\n                float line = min(min(grid.x, grid.y), grid.z);\n                float value = 3.- min(line,3.);\n                float transparency = .1 + value * .9;\n            \n                gl_FragColor = vec4(v_Normal * value, transparency);\n                // vec3 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);\n            }`,\n        transparent: true,\n        uniforms: {},\n        extensions: {derivatives: true}\n    },\n\n    grid: {\n        vertexShader: `\n            varying vec3 v_Position;\n            void main() {\n                v_Position = position;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            varying vec3 v_Position;\n            void main() {\n                vec3 grid = abs(fract(v_Position - .5) - .5) / fwidth(v_Position);\n                float line = min(min(grid.x, grid.y), grid.z);\n                float value = 2.5- min(line, 2.5);\n                float transparency = .1 + value * .9;\n\n                gl_FragColor = vec4(vec3(0.), transparency);\n                // vec3 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);\n            }`,\n        transparent: true,\n        uniforms: {},\n        extensions: {derivatives: true}\n    },\n\n    zGrid: {\n        vertexShader: `\n            varying float z_Position;\n            varying vec3 v_Normal;\n            void main() {\n                z_Position = position.z;\n                v_Normal = normal;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            varying float z_Position;\n            varying vec3 v_Normal;\n            void main() {\n                float line = abs(fract(z_Position - 0.5) - 0.5) / fwidth(z_Position);\n                float value = 3.- min(line,3.);\n                float transparency = .1 + value * .9;\n    \n                gl_FragColor = vec4(v_Normal * value, transparency);\n                // vec3 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);\n            }`,\n        transparent: true,\n        uniforms: {},\n        extensions: {derivatives: true}\n    },\n\n    edges: {\n        vertexShader: `\n            attribute vec2 barycentric;\n            varying vec2 b;\n            void main () {\n                b = barycentric;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            // float gridFactor (vec2 vBC, float width, float feather) {\n            //     float w1 = width - feather * 0.5;\n            //     vec3 bary = vec3(vBC.x, vBC.y, 1.0 - vBC.x - vBC.y);\n            //     vec3 d = fwidth(bary);\n            //     vec3 a3 = smoothstep(d * w1, d * (w1 + feather), bary);\n            //    \n            //     return min(min(a3.x, a3.y), a3.z);\n            // }\n            \n            float gridFactor (vec2 vBC, float width) {\n                vec3 bary = vec3(vBC.x, vBC.y, 1.0 - vBC.x - vBC.y);\n                vec3 d = fwidth(bary);\n                vec3 a3 = smoothstep(d * (width - 0.5), d * (width + 0.5), bary);\n                \n                return min(min(a3.x, a3.y), a3.z);\n            }\n            \n            varying vec2 b;\n            \n            void main () {\n                gl_FragColor = vec4(vec3(gridFactor(b, 1.0) * .6), 1);\n            }`,\n        transparent: true,\n        extensions: {derivatives: true}\n    }\n}\n","import {DelaunayTriangulationBuilder} from \"jsts/org/locationtech/jts/triangulate\";\nimport {WKTReader} from \"jsts/org/locationtech/jts/io\";\nimport BufferOp from \"jsts/org/locationtech/jts/operation/buffer/BufferOp\";\nimport {Geometry, GeometryCollection, GeometryFactory} from \"jsts/org/locationtech/jts/geom\";\nimport \"jsts/org/locationtech/jts/monkey.js\";\nimport {BufferAttribute, BufferGeometry, LineCurve, Vector3} from \"three\";\nimport {CustomLine} from \"./test-geo\";\nimport {UnaryUnionOp} from \"jsts/org/locationtech/jts/operation/union\";\n\nfunction triangulationFromPolygon(polygon) {\n    const builder = new DelaunayTriangulationBuilder();\n\n    builder.setSites(polygon);\n    builder.setTolerance(.01);\n\n    let triangulation = builder.getTriangles(new GeometryFactory());\n\n    // console.log(triangulation);\n\n    return triangulation;\n}\n\nfunction polygonToBufferGeometry(polygon) {\n    const triangulation = triangulationFromPolygon(polygon);\n    return bufferFromTriangulation(triangulation);\n}\n\nfunction edgesFromTriangulation(triangulation) {\n    let vertexDict = {};\n    let vPairs = {};\n    let pureVertices = {};\n\n    for (const boundary in triangulation._geometries) {\n        const bnd = triangulation.getGeometryN(boundary);\n        const coords = bnd.getCoordinates();\n\n        if (coords.length === 4) {\n            let cMap = [0, 0, 0];\n            for (const idx in [0,1,2]) {\n                const coor = coords[idx];\n\n                let coordinate = JSON.stringify({x: coor.x, y: coor.y, z: .1});\n\n                const dictCount = Object.keys(vertexDict).length;\n\n                if (!(coordinate in vertexDict)) {\n                    // console.log(coordinate);\n\n                    vertexDict[coordinate] = dictCount;\n                    pureVertices[coordinate] = new Vector3(coor.x, coor.y, .1);\n                    cMap[idx] = dictCount;\n                } else {\n                    cMap[idx] = vertexDict[coordinate];\n                }\n            }\n\n            // console.log(cMap);\n\n            for (const idx in [0,1,2]) {\n                let a = cMap[idx];\n                let b = cMap[(idx + 1) % 3];\n\n                let v0 = Math.min(a, b);\n                let v1 = Math.max(a, b);\n\n                vPairs[JSON.stringify([v0, v1])] = [v0, v1];\n            }\n        }\n    }\n\n    let idxVertex = {};\n    for(const v in vertexDict){\n        const idx = vertexDict[v];\n        idxVertex[idx] = pureVertices[v];\n    }\n\n    let lines = [];\n\n    for (const idx in vPairs) {\n        // console.log(vPairs[idx]);\n\n        const a = vPairs[idx][0];\n        const b = vPairs[idx][1];\n\n        // console.log(vPairs);\n        // console.log(a, b);\n        // console.log(idxVertex[a], idxVertex[b]);\n\n        const localLineCurve = new LineCurve(idxVertex[a], idxVertex[b]);\n\n        // localLineCurve.arcLengthDivisions = 1;\n\n        lines.push(localLineCurve);\n    }\n\n    return lines;\n}\n\nfunction bufferFromTriangulation(triangulation) {\n    // let geoCollection = new GeometryCollection();\n\n    let bufferGeo = new BufferGeometry();\n    let coordinatesList = [];\n\n    for (const boundary in triangulation._geometries) {\n        const bnd = triangulation.getGeometryN(boundary);\n        const coords = bnd.getCoordinates();\n\n        if (coords.length === 4) {\n            for (const idx in [0,1,2]) {\n                const coor = coords[idx];\n                coordinatesList.push(coor.x);\n                coordinatesList.push(coor.y);\n                coordinatesList.push(.1);\n            }\n        }\n    }\n\n    const vertices = new Float32Array( coordinatesList );\n\n    bufferGeo.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n    bufferGeo.computeVertexNormals();\n\n    return bufferGeo;\n}\n\nexport function createBuffer(geom, radius, segments = 32) {\n    return BufferOp.bufferOp(geom, radius, segments);\n}\n\nexport function displayPoint(aString) {\n    let reader = new WKTReader();\n\n    let pt = reader.read(aString);\n\n    let buffered = createBuffer(pt, 20);\n\n    const triangulation = triangulationFromPolygon(buffered);\n\n    return {\n        buffer: bufferFromTriangulation(triangulation),\n        edges: edgesFromTriangulation(triangulation)\n    };\n}\n\nexport function geometriesUnion(geos) {\n    if (geos.length === 1){\n        return geos[0];\n    }\n\n    const geoFac = new GeometryFactory();\n    const geoCollection = geoFac.createGeometryCollection(geos).union();\n\n    return geoCollection;\n}\n\nexport function geometriesDifference(geosA, geosB) {\n    return geosA.difference(geosB);\n}\n\nexport function geometriesIntersection(geosA, geosB) {\n    return geosA.intersection(geosB);\n}\n\nexport function readWKString(strings) {\n    const reader = new WKTReader();\n    const geos = [];\n\n    for (const aString of strings) {\n        geos.push(reader.read(aString));\n    }\n\n    return geos;\n}\n\nexport function geometryUnion(geos) {\n    const collection = geometriesUnion(geos);\n\n    return UnaryUnionOp.union(collection);\n}\n\nexport function multiplePoints(){\n    const strings = [\n        'POINT (-20 0)',\n        'POINT (20 0)',\n        'POINT (0 15)'\n    ];\n\n    const geos = readWKString(strings);\n    let bufferedGeos = [];\n\n    for (const geo of geos) {\n        bufferedGeos.push(BufferOp.bufferOp(geo, 30, 100));\n    }\n\n    const geom = geometryUnion(bufferedGeos);\n\n    return geom;\n}\n\nexport function triangulatePolyline(plg) {\n    const triangulation = triangulationFromPolygon(plg);\n\n    return {\n        buffer: bufferFromTriangulation(triangulation),\n        edges: edgesFromTriangulation(triangulation)\n    };\n}\n\nexport function testPolygon() {\n    // let reader = new WKTReader();\n    //\n    // const pt = reader.read('POINT (0 0)');\n    // const buffer = BufferOp.bufferOp(pt, 30)\n\n    return multiplePoints();\n}\n\nexport function displayPointTest(){\n    return triangulatePolyline(multiplePoints());\n}\n","import {Curve, Matrix4, Vector3} from \"three\";\nimport {clamp} from \"three/src/math/MathUtils\";\n\nexport class CustomSinCurve extends Curve {\n\n    constructor( scale = 1 ) {\n\n        super();\n\n        this.scale = scale;\n\n    }\n\n    getPoint( t, optionalTarget = new Vector3() ) {\n\n        const tx = t * 3 - 1.5;\n        const ty = Math.sin( 2 * Math.PI * t );\n        const tz = 0;\n\n        return optionalTarget.set( tx, ty, tz ).multiplyScalar( this.scale );\n    }\n}\n\nexport class CustomLine extends Curve {\n\n    constructor(v0, v1) {\n        super();\n\n        this.v0 = v0;\n        this.vDir = v1 - this.v0;\n\n        this.scale = 1.;\n    }\n\n    getPoint(t, optionalTarget = new Vector3()) {\n        const v = this.v0 + t * this.vDir;\n        // console.log(v);\n\n        return optionalTarget.set(v.x, v.y, v.z).multiplyScalar( this.scale );\n    }\n}\n\nexport class Polyline extends Curve {\n    constructor(points, closed = true) {\n        super();\n\n        this.points = points;\n        this.closed = closed;\n\n        this.init();\n    }\n\n    init() {\n        this.dirs = this.getDirs();\n\n        this.arcLengthDivisions = this.getPointCount();\n    }\n\n    getPointCount() {\n        if (this.closed) {\n            return this.points.length;\n        } else {\n            return this.points.length - 1;\n        }\n    }\n\n    getDirs() {\n        let dirList = [];\n\n        for (let i = 0; i < this.getPointCount(); i++) {\n            const v0 = this.points[i];\n            const v1 = this.points[(i+1) % this.getPointCount()];\n\n            const vDir = new Vector3().subVectors(v1, v0);\n\n            dirList.push(vDir);\n        }\n\n        return dirList;\n    }\n\n    getLength() {\n        const lengths = this.getLengths();\n        return lengths[lengths.length - 1];\n    }\n\n    getLengths() {\n        if ( this.cacheArcLengths &&\n            ( this.cacheArcLengths.length === this.getPointCount() + 1 ) &&\n            ! this.needsUpdate ) {\n\n            return this.cacheArcLengths;\n        }\n\n        let previous = 0.;\n        this.cacheArcLengths = [previous];\n\n        for (const dir of this.dirs) {\n            previous += dir.length();\n            this.cacheArcLengths.push(previous);\n        }\n\n        return this.cacheArcLengths;\n    }\n\n    getTangentAt(u, optionalTarget = new Vector3()) {\n        return this.getTangent(u * this.getPointCount(), optionalTarget)\n    }\n\n    getTangent(t, optionalTarget = new Vector3()) {\n        const locT = t % 1.;\n        let roundT = t - t % 1.;\n\n        if (isNaN(t)) {\n            return null;\n        }\n\n        let vT;\n\n        if (t > 0 && t < this.getPointCount()) {\n            if ( locT < .0001 ) {\n                const v1 = new Vector3().copy(this.dirs[roundT]);\n                const v0 = new Vector3().copy(this.dirs[roundT - 1]);\n\n                v0.normalize();\n                v1.normalize();\n\n                vT = new Vector3().addVectors(v0, v1);\n            } else {\n                vT = new Vector3().copy(this.dirs[roundT]);\n            }\n        }\n\n        if (this.closed) {\n            roundT %= this.getPointCount();\n\n            if ( locT < .0001 ) {\n                const v1 = new Vector3().copy(this.dirs[roundT]);\n                const v0 = new Vector3().copy(this.dirs[(roundT + this.getPointCount() - 1) % this.getPointCount()]);\n\n                v0.normalize();\n                v1.normalize();\n\n                vT = new Vector3().addVectors(v0, v1);\n            } else {\n                vT = new Vector3().copy(this.dirs[roundT]);\n            }\n        } else {\n            if (t < 1) {\n                vT = new Vector3().copy(this.dirs[0]);\n            } else {\n                vT = new Vector3().copy(this.dirs[this.dirs.length - 1]);\n            }\n        }\n\n        vT.normalize();\n        return optionalTarget.set(vT.x, vT.y, vT.z);\n    }\n\n    computeFrenetFrames( segments, closed ) {\n\n        // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n        const normal = new Vector3();\n\n        const tangents = [];\n        const normals = [];\n        const binormals = [];\n\n        const vec = new Vector3();\n        const mat = new Matrix4();\n\n        // compute the tangent vectors for each segment on the curve\n\n        for ( let i = 0; i <= segments; i ++ ) {\n\n            const u = i / segments;\n\n            tangents[ i ] = this.getTangentAt( u, new Vector3() );\n\n        }\n\n        // select an initial normal vector perpendicular to the first tangent vector,\n        // and in the direction of the minimum tangent xyz component\n\n        normals[ 0 ] = new Vector3();\n        binormals[ 0 ] = new Vector3();\n        let min = Number.MAX_VALUE;\n        const tx = Math.abs( tangents[ 0 ].x );\n        const ty = Math.abs( tangents[ 0 ].y );\n        const tz = Math.abs( tangents[ 0 ].z );\n\n        if ( tx <= min ) {\n\n            min = tx;\n            normal.set( 1, 0, 0 );\n\n        }\n\n        if ( ty <= min ) {\n\n            min = ty;\n            normal.set( 0, 1, 0 );\n\n        }\n\n        if ( tz <= min ) {\n\n            normal.set( 0, 0, 1 );\n\n        }\n\n        vec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n        normals[ 0 ].crossVectors( tangents[ 0 ], vec );\n        binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n        // compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n        for ( let i = 1; i <= segments; i ++ ) {\n\n            normals[ i ] = normals[ i - 1 ].clone();\n\n            binormals[ i ] = binormals[ i - 1 ].clone();\n\n            vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n            if ( vec.length() > Number.EPSILON ) {\n\n                vec.normalize();\n\n                const theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n                normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n            }\n\n            binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n        }\n\n        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n        if ( closed === true ) {\n\n            let theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n            theta /= segments;\n\n            if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n                theta = - theta;\n\n            }\n\n            for ( let i = 1; i <= segments; i ++ ) {\n\n                // twist a little...\n                normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n                binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n            }\n\n        }\n\n        // console.log({\n        //     tangents: tangents,\n        //     normals: normals,\n        //     binormals: binormals\n        // });\n\n        return {\n            tangents: tangents,\n            normals: normals,\n            binormals: binormals\n        };\n\n    }\n\n    _tConstraining(t) {\n        let locT = t % 1.;\n\n        let t0 = t - locT;\n\n        if (this.closed) {\n            t0 %= this.getPointCount();\n        } else {\n            if (t0 < 0) {\n                locT += t0;\n                t0 = 0;\n            } else if (t0 >= this.getPointCount()) {\n                locT += t0 - this.getPointCount();\n                t0 = this.getPointCount();\n            }\n        }\n\n        return {\n            locT: locT,\n            t0: t0\n        };\n    }\n\n    getPointAt(t, optionalTarget = new Vector3() ) {\n        return this.getPoint(t, optionalTarget);\n    }\n\n    getPoint( t, optionalTarget = new Vector3() ) {\n        t *= this.getPointCount();\n\n        const {locT, t0} = this._tConstraining(t);\n\n        const v0 = this.points[t0];\n        const vDir = this.dirs[t0];\n\n        const v = new Vector3().addVectors(v0, new Vector3().addScaledVector(vDir, locT));\n\n        return optionalTarget.set(v.x, v.y, v.z);\n    }\n\n    moveToHeight(height = 0.){\n        for (const point of this.points) {\n            point.z = height;\n        }\n    }\n\n    makeMeWave(periods = 2., amplitude = 5.) {\n        const step = (periods * 2. * Math.PI) / this.getPointCount();\n        let phase = 0.;\n\n        for (let i = 0; i < this.getPointCount(); i++ ) {\n            this.points[i].z += amplitude * Math.sin(phase);\n            phase += step;\n        }\n\n        this.init();\n    }\n}","import {GeometryFactory} from \"jsts/org/locationtech/jts/geom\";\nimport {ClayPoint} from './clay-point';\nimport {Vector3} from \"three\";\nimport {Polyline} from \"../three/three-poly-line\";\n\nexport class ClayPatternCurve {\n    clayPoints;\n\n    constructor(clayPoints) {\n        this.clayPoints = clayPoints;\n    }\n\n    toPolygon() {\n        let coordinates =[];\n\n        for (const pt of this.clayPoints) {\n            coordinates.push(pt.toCoordinate());\n        }\n\n        coordinates.push(coordinates[0]);\n\n        return new GeometryFactory().createPolygon(coordinates);\n    }\n\n    toPolyline() {\n        let positions = [];\n\n        for (const pt of this.clayPoints) {\n            positions.push(pt.toVector3());\n        }\n\n        return new Polyline(positions);\n    }\n\n    moveToHeight(height = 0.) {\n        for (const pt of this.clayPoints) {\n            pt.z = height;\n        }\n    }\n}\n\nexport function testClayCurve(scene = null) {\n    let pts = [\n        new ClayPoint(\n            new Vector3(.5, .5, 0),\n            new Vector3(1, 1, 0),\n        ),\n        new ClayPoint(\n            new Vector3(-.5, .5, 0),\n            new Vector3(-1, 1, 0),\n        ),\n        new ClayPoint(\n            new Vector3(-.5, -.5, 0),\n            new Vector3(-1, -1, 0),\n        ),\n        new ClayPoint(\n            new Vector3(.5, -.5, 0),\n            new Vector3(1, -1, 0),\n        ),\n    ];\n\n    const clayCurve = new ClayPatternCurve(pts);\n\n    if (scene) {\n        // console.log(\"is not null?\");\n        // console.log(scene);\n\n\n\n    } else {\n        console.log(\"is null !!!\");\n    }\n}\n","import {GeometryFactory} from \"jsts/org/locationtech/jts/geom\";\nimport {Path, Vector3} from \"three\";\nimport {Polyline} from \"../three/three-poly-line\";\nimport {testPolygon} from \"../importing-jsts\";\n\nconst llr = new GeometryFactory().createLinearRing();\n\nfunction getLinearRings(polygon) {\n    let linearRings = [];\n    linearRings.push(polygon.getExteriorRing());\n\n    // console.log(polygon);\n\n    for (let i = 0; i < polygon.getNumInteriorRing(); i++) {\n        linearRings.push(polygon.getInteriorRingN(i));\n    }\n\n    return linearRings;\n}\n\nfunction vectorFromCoordinate(coordinate) {\n    let locZ;\n\n    if (isNaN(coordinate.z)) {\n        locZ = 0;\n    } else {\n        locZ = coordinate.z;\n    }\n\n    return new Vector3(\n        coordinate.x,\n        coordinate.y,\n        locZ\n    );\n}\n\nfunction linearRingToPolyline(linearRing) {\n    let vectors = [];\n\n    for (const coordinate of linearRing.getCoordinates()) {\n        vectors.push(vectorFromCoordinate(coordinate) );\n    }\n\n    vectors.pop();\n\n    return new Polyline(vectors);\n}\n\nexport function polygonToPolylines(polygon){\n    let polylines = [];\n\n    if (polygon.constructor.name === \"MultiPolygon\") {\n        for (const pg of polygon._geometries) {\n            for (const pl of polygonToPolylines(pg)){\n                polylines.push(pl);\n            }\n        }\n\n        return polylines;\n    }\n\n    const lrs = getLinearRings(polygon);\n\n    for (const lr of lrs){\n        polylines.push(linearRingToPolyline(lr));\n    }\n\n    return polylines;\n}\n","import {GeometryFactory} from \"jsts/org/locationtech/jts/geom\";\nimport Coordinate from \"jsts/org/locationtech/jts/geom/Coordinate\";\n\nfunction vector3toCoordinate(vector3) {\n    return new Coordinate(vector3.x, vector3.y, vector3.z);\n}\n\nfunction coordinatesFromPolyline(polyline) {\n    let coordinates = [];\n\n    for (const pt of polyline.points) {\n        coordinates.push(vector3toCoordinate(pt));\n    }\n\n    coordinates.push(coordinates[0]);\n\n    return coordinates;\n}\n\nexport function polylineToPolygon(polyline) {\n    const geoFactory = new GeometryFactory();\n\n    let coordinates = [];\n\n    const polygon = geoFactory.createPolygon(coordinatesFromPolyline(polyline));\n\n    return polygon;\n};","// defining base parameters\n// all lengths are in mm\n// base height, width\n\nimport {ClayPatternCurve} from \"./clay-pattern-curve\";\nimport {Polyline} from \"../three/three-poly-line\";\nimport {polylineToPolygon} from \"../jsts2Three/three-to-jsts\";\nimport {createBuffer, geometriesDifference, geometriesIntersection, geometryUnion} from \"../importing-jsts\";\nimport {polygonToPolylines} from \"../jsts2Three/jsts-to-three\";\n\nconst productionWidth = 5.0;\n\nconst {Vector3} = require(\"three\");\nconst {ClayPoint} = require(\"./clay-point\");\nconst baseWidth = 150.0;\nconst baseLength = 300.0; // always needs to be at least the same length as the brick's width\nconst lengthBufferMultiplier = 2.0;\n\nconst pinSpacing = 220.0;\nconst diamondWidth = 60.0;\nconst diamondHeight = 100.0;\nconst diamondCount = 3;\n\nconst pinDiameter0 = 40.0;\nconst pinDiameter1 = 20.0;\nconst pinDelta = 250.0;\nconst pinDiameterDelta = (pinDiameter1 - pinDiameter0) / pinDelta;\nconst pinDivisions = 60;\n\nconst precision = 5.0;\n\nconst bodyHeight = 160.0;\n\nfunction pinRadiusAtHeight(height) {\n    // console.log(pinDiameterDelta, height, pinDiameter0);\n    return pinDiameterDelta * height + pinDiameter0;\n}\n\nfunction arcDivisions(radius, goalLength, arcAngle, startPhase, basePoint, clayPoints) {\n    const count = Math.ceil(arcAngle * radius / goalLength);\n    const angleDelta = arcAngle / count;\n\n    for (let i = 0; i < count; i++) {\n        const angle = startPhase + angleDelta * i;\n\n        const x0 = Math.cos(angle);\n        const y0 = Math.sin(angle);\n\n        const x = radius * x0;\n        const y = radius * y0;\n\n        clayPoints.push(new ClayPoint(\n            new Vector3(basePoint.x + x, basePoint.y + y, basePoint.z),\n            new Vector3(x0, y0, 0)\n        ));\n    }\n}\n\nfunction lineDivisions(v0, v1, goalLength, clayPoints) {\n    const length = v0.distanceTo(v1);\n    const count = Math.ceil( length/ goalLength);\n\n    const delta = new Vector3().addScaledVector(\n        new Vector3().subVectors(v1, v0),\n        1. / count\n    );\n\n    const normal = new Vector3(-delta.y / delta.length(), delta.x / delta.length());\n\n    for (let i = 0; i < count; i++) {\n        const v = new Vector3().addVectors(\n            v0,\n            new Vector3().addScaledVector(delta, i)\n        );\n\n        clayPoints.push(new ClayPoint(\n            v,\n            normal\n        ));\n    }\n}\n\nexport function outerProfile(height = 0.) {\n    const v0 = new Vector3(-(baseLength - baseWidth) * .5, 0.0, height);\n    const v1 = new Vector3((baseLength - baseWidth) * .5, 0.0, height);\n\n    let clayPoints = [];\n\n    arcDivisions(baseWidth * .5, precision, Math.PI, .5 *Math.PI, v0, clayPoints);\n\n    const p0 = new Vector3(-(baseLength - baseWidth) * .5, -baseWidth * .5, height);\n    const p1 = new Vector3((baseLength - baseWidth) * .5, -baseWidth * .5, height);\n\n    lineDivisions(p0, p1, precision, clayPoints);\n\n    arcDivisions(baseWidth * .5, precision, Math.PI, -.5 *Math.PI, v1, clayPoints);\n\n    const p2 = new Vector3((baseLength - baseWidth) * .5, baseWidth * .5, height);\n    const p3 = new Vector3(-(baseLength - baseWidth) * .5, baseWidth * .5, height);\n\n    lineDivisions(p2, p3, precision, clayPoints);\n\n    const clayPolyline = new ClayPatternCurve(clayPoints);\n\n    return clayPolyline;\n}\n\nfunction simpleLineDivison(v0, v1, divisions, withEnds = false) {\n    const delta = new Vector3().addScaledVector(\n        new Vector3().subVectors(v1, v0),\n        1. / divisions\n    );\n\n    let vs = [];\n\n    let start = 0;\n    let end = divisions + 1;\n\n    if (!withEnds) {\n        start = 1;\n        end = divisions;\n    }\n\n    for (let i = start; i < end; i++) {\n        const v = new Vector3().addVectors(\n            v0,\n            new Vector3().addScaledVector(delta, i)\n        );\n\n        vs.push(v);\n    }\n\n    return vs;\n}\n\nfunction simpleArcDivision(baseV, radius, arcAngle = Math.PI, startPhase = 0., division = 100) {\n    const delta = arcAngle / division;\n\n    let vs = [];\n\n    for (let i = 0; i < division; i++) {\n        const angle = startPhase + i * delta;\n\n        const x = radius * Math.cos(angle);\n        const y = radius * Math.sin(angle);\n\n        vs.push(new Vector3(baseV.x + x, baseV.y + y, 0));\n    }\n\n    return new Polyline(vs);\n}\n\nfunction diamondPolyline(bPoint) {\n    return new Polyline([\n        new Vector3(bPoint.x + diamondWidth * .5, bPoint.y, 0),\n        new Vector3(bPoint.x, bPoint.y + diamondHeight * .5, 0),\n        new Vector3(bPoint.x - diamondWidth * .5, bPoint.y, 0),\n        new Vector3(bPoint.x, bPoint.y - diamondHeight * .5, 0)\n    ]);\n}\n\nfunction rectangle(bPoint, width, height) {\n    return new Polyline([\n        new Vector3(bPoint.x + width * .5, bPoint.y + .5 * height, 0),\n        new Vector3(bPoint.x - width * .5, bPoint.y + .5 * height, 0),\n        new Vector3(bPoint.x - width * .5, bPoint.y - .5 *  height, 0),\n        new Vector3(bPoint.x + width * .5, bPoint.y - .5 *  height, 0)\n    ]);\n}\n\nexport function innerProfileGeom(height = 0.) {\n    const v0 = new Vector3(-pinSpacing * .5, 0.0);\n    const v1 = new Vector3(pinSpacing * .5, 0.0);\n\n    const diamondVs = simpleLineDivison(v0, v1, diamondCount + 1, false);\n\n    let pls = [];\n\n    for (const diamondV of diamondVs) {\n        const diamond = diamondPolyline(diamondV);\n        const diamondRect = rectangle(diamondV, productionWidth, baseWidth * lengthBufferMultiplier);\n\n        pls.push(diamond);\n        pls.push(diamondRect);\n    }\n\n    const pinDiameter = pinRadiusAtHeight(height);\n\n    pls.push(simpleArcDivision(v0, pinDiameter * .5, 2. * Math.PI, 0., pinDivisions));\n    pls.push(simpleArcDivision(v1, pinDiameter * .5, 2. * Math.PI, 0., pinDivisions));\n    pls.push(rectangle(v0, productionWidth, baseWidth * lengthBufferMultiplier));\n    pls.push(rectangle(v1, productionWidth, baseWidth * lengthBufferMultiplier));\n    pls.push(rectangle(new Vector3(0, 0, 0),baseLength + baseWidth * (lengthBufferMultiplier - 1.), productionWidth));\n\n    let polygons = [];\n    for (const pl of pls){\n        polygons.push(polylineToPolygon(pl));\n    }\n\n    const geom = geometryUnion(polygons);\n\n    return geom;\n}\n\nexport function innerProfile(height = 0.) {\n    const geom = innerProfileGeom(height);\n\n    const polylines = polygonToPolylines(geom);\n\n    for (const pl of polylines) {\n        pl.moveToHeight(height);\n    }\n\n    return polylines;\n}\n\nexport function aSlice(height = 0.) {\n    const outerClayCurve = outerProfile(height);\n\n    // need to apply a certain pattern logic to it\n    // not pattern for now!\n\n    const outerGeom = outerClayCurve.toPolygon();\n\n    const bufferedOuterGeom = createBuffer(outerGeom, -productionWidth, 1);\n\n    const innerGeom = innerProfileGeom(height);\n\n    const geom = geometriesIntersection(bufferedOuterGeom, innerGeom);\n\n    let polylines = polygonToPolylines(geom);\n    for (const pl of polygonToPolylines(outerGeom)) {\n        polylines.push(pl);\n    }\n\n    for (const pl of polylines) {\n        pl.moveToHeight(height);\n    }\n    return polylines;\n}\n\n","import {\n    Curve,\n    // EdgesGeometry,\n    // CurveLine,\n    // LineBasicMaterial,\n    // LineSegments,\n    Matrix4,\n    Mesh,\n    ShaderMaterial,\n    // Vector2,\n    Vector3\n} from \"three\";\nimport {SpecialTubeGeo, TubeGeo} from \"./to-three\";\nimport {shaders} from \"./shaders-materials\";\nimport {displayPointTest, testPolygon} from \"./importing-jsts\";\nimport {clayPointTest} from \"./clayBrick/clay-point\";\nimport {testClayCurve} from \"./clayBrick/clay-pattern-curve\";\nimport {polygonToPolylines} from \"./jsts2Three/jsts-to-three\";\nimport {aSlice, innerProfile, outerProfile} from \"./clayBrick/clay-simple-base\";\nimport {CustomSinCurve} from \"./three/three-poly-line\";\n\nfunction shaderMaterialEdges() {\n    return new ShaderMaterial( shaders.grid );\n}\n\nexport function shaderNormal() {\n    return new ShaderMaterial(shaders.normalShader);\n}\n\nexport function testTube() {\n    // const material = new MeshBasicMaterial( { color: 0xff2211 } );\n    const material = shaderMaterialEdges();\n    const path = new CustomSinCurve( 10 );\n\n    return TubeGeo(path, 100, 2., 32, false, material);\n}\n\nexport function testJSTSTriangulation(scene) {\n    const {buffer, edges} = displayPointTest();\n    const material = shaderMaterialEdges();\n\n    const mesh = new Mesh(buffer, material);\n\n    const blWhiteShader = new ShaderMaterial(shaders.normalShader);\n\n    for (const line in edges) {\n        const aLine = edges[line];\n\n        // console.log(aLine);\n\n        const locTubeGeo = TubeGeo(aLine, 32, .5, 32, false, blWhiteShader);\n\n        // console.log(locTubeGeo);\n        scene.add(locTubeGeo);\n    }\n\n    scene.add(mesh);\n}\n\nexport function geoTubeTest() {\n    const polygon = testPolygon();\n    const pls = polygonToPolylines(polygon);\n\n    const blWhiteShader = new ShaderMaterial(shaders.normalShader);\n\n    let tubes = [];\n    for (const pl of pls) {\n        pl.makeMeWave(4., 10.);\n        tubes.push(TubeGeo(pl, pl.getPointCount(), .5, 6, false, blWhiteShader))\n    }\n\n    return tubes;\n}\n\n\nexport function addTestGeos(scene) {\n    scene.add(testTube());\n\n    //\n    // basePl.makeMeWave(4., 10.);\n\n\n\n    for (let i = 1.25; i < 160.; i += 2.5) {\n        for (const pl of aSlice(i)) {\n            const locTubeGeo = TubeGeo(pl, pl.getPointCount(), 1.5, 6, false, shaderNormal());\n            scene.add(locTubeGeo);\n        }\n    }\n\n\n    clayPointTest();\n    testClayCurve(scene);\n\n    for (const tube of geoTubeTest()) {\n        scene.add(tube);\n    }\n}\n","import {WebGL1Renderer, WebGLRenderer} from 'three'\n\nexport function getPlanarRenderer() {\n    const renderer = new WebGLRenderer({antialias: true});\n\n    renderer.setClearColor('#cdd0d6');\n    renderer.setPixelRatio(window.devicePixelRatio);\n\n    return renderer;\n}\n\nexport function getPerspectiveRenderer() {\n    const renderer = new WebGL1Renderer({antialias: true, alpha: true})\n\n    renderer.setClearColor('#ffff99');\n    renderer.setPixelRatio(window.devicePixelRatio);\n\n    return renderer;\n}\n\nexport function resize(mount, renderer, camera) {\n    if (!mount || !renderer || !camera)\n        return\n\n    const {clientWidth, clientHeight} = mount.current\n\n    if (camera) {\n        camera.aspect = clientWidth / clientHeight;\n        camera.updateProjectionMatrix();\n    }\n\n    renderer.setSize(clientWidth, clientHeight)\n}\n","export function start(renderer, scene, camera) {\n\n    const frameId = {frameId: null};\n\n    frameId.frameId = requestAnimationFrame(() => animate(renderer, scene, camera, frameId));\n\n    return frameId;\n}\n\nexport function stop({frameId}) {\n    return cancelAnimationFrame(frameId);\n}\n\nfunction animate(renderer, scene, camera, frameId) {\n    renderer.clear('#ddd');\n    renderer.render(scene, camera);\n\n    frameId.frameId = requestAnimationFrame(() => animate(renderer, scene, camera, frameId));\n}\n","import {Scene} from 'three';\nimport {getPerspectiveRenderer, resize} from \"./renderers\";\nimport {getOrbitControls} from \"./orbit-controls\";\nimport {getPerspectiveCamera} from \"./cameras\";\nimport {start, stop} from \"./render-loops\";\nimport {addTestGeos, testTube} from \"../geometry/test-geo\";\nimport {displayPointTest} from \"../geometry/importing-jsts\";\n\nexport function setUp(mount) {\n    const scene = new Scene();\n\n    addTestGeos(scene);\n\n    displayPointTest();\n\n    const renderer = getPerspectiveRenderer();\n    mount.current.appendChild(renderer.domElement);\n\n    const camera = getPerspectiveCamera(mount.current);\n    scene.add(camera);\n\n    const orbitControls = getOrbitControls(camera, renderer);\n\n    resize(mount, renderer, camera);\n    const frameId = start(renderer, scene, camera);\n\n    return {\n        scene: scene,\n        renderer: renderer,\n        camera: camera,\n        frameId: frameId,\n        orbitControls: orbitControls\n    };\n}\n\nexport function cleanUp(mount, renderer, frameId) {\n    stop(frameId.frameId);\n    mount.current.removeChild(renderer.domElement);\n}\n","import {OrthographicCamera, PerspectiveCamera} from 'three'\n\nexport function getOrthographicCamera(mount) {\n    const {clientWidth, clientHeight} = mount;\n\n    const camera = new OrthographicCamera(\n        clientWidth / -16,\n        clientWidth /16,\n        clientHeight / 16,\n        clientHeight / -16,\n        -1,\n        100\n    );\n\n    camera.enableRotate = false;\n    camera.position.z = 20;\n\n    return camera;\n}\n\nexport function getPerspectiveCamera(mount) {\n    const {clientWidth, clientHeight} = mount;\n\n    const camera = new PerspectiveCamera(\n        45,\n        clientWidth / clientHeight\n    );\n\n    camera.position.z = 20;\n    return camera;\n}\n","import {MOUSE} from 'three';\nimport {OrbitControls} from \"three/examples/jsm/controls/OrbitControls\";\n\nexport function getOrbitControls(camera, renderer) {\n    const orbitControls = new OrbitControls(camera, renderer.domElement);\n    orbitControls.enableRotate = true;\n    orbitControls.enableKeys = true;\n    // orbitControls.minZoom = .5;\n    // orbitControls.maxZoom = 8;\n    // orbitControls.mouseButtons = {ZOOM: MOUSE.MIDDLE, PAN: MOUSE.RIGHT};\n\n    orbitControls.target.set(0, 0);\n    orbitControls.update();\n\n    return orbitControls;\n}\n\n","import React, {useEffect, useRef} from 'react';\nimport Measure from 'react-measure';\nimport {cleanUp, setUp} from \"./three-setup/set-up\";\nimport {resize} from \"./three-setup/renderers\";\nimport {GUI} from 'three/examples/jsm/libs/dat.gui.module';\nimport {createGUI} from \"./three-setup/gui-setup\";\n\nimport './Viewer.scss';\n\nfunction Viewer() {\n    const mount = useRef(null);\n    const rendererRef = useRef(null);\n    const cameraRef = useRef(null);\n\n    let gui;\n\n\n    useEffect(() => {\n        console.log(mount);\n\n        const {scene, camera, renderer, frameId} = setUp(mount);\n\n        rendererRef.current = renderer;\n        cameraRef.current = camera;\n\n        gui = createGUI(scene);\n\n        return () => {\n            cleanUp(mount, renderer, frameId);\n        }\n    }, [rendererRef, cameraRef]);\n\n    return (\n        <Measure\n            bounds\n            onResize={() => {\n                resize(mount, rendererRef.current, cameraRef.current)\n            }}>\n            {({measureRef}) => (\n                <div className={'simple-3d'} ref={measureRef}>\n                    <div className={'three-canvas'} ref={mount} tabIndex={0}/>\n                </div>\n            )}\n        </Measure>\n    )\n}\n\nexport default Viewer;\n","import {GUI} from \"three/examples/jsm/libs/dat.gui.module\";\nimport {USDZExporter} from \"three/examples/jsm/exporters/USDZExporter\";\n\nexport function createGUI(scene) {\n    const gui = new GUI();\n\n    const exportUSDZ = { usdz:function(){\n        console.log(\"export USDZ !?\");\n\n        // const exporter = new USDZExporter();\n        // const arrayBuffer = exporter.parse( scene, function ( ucsd ) {\n        //     console.log(ucsd);\n        //     console.log(\"nothing ?\");\n        //\n        // }, {} );\n        //\n        // const blob = new Blob( [ arrayBuffer ], { type: 'application/octet-stream' } );\n        //\n        // // console.log(ucsd);\n        // console.log(document);\n        //\n        // const link = document.getElementById( 'link' );\n        //\n        // console.log(link);\n        //\n        // link.href = URL.createObjectURL( blob );\n\n    }};\n\n    gui.add(exportUSDZ,'usdz');\n\n    return gui;\n}\n","// ... App.js\nimport React, {Component} from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as THREE from \"three\";\nimport {TestGeo} from \"./geometry/test-geo\";\nimport {setUp} from \"./three-setup/set-up\";\n\nimport './App.css';\nimport Viewer from \"./Viewer\";\n\nfunction App() {\n    return (\n        <div className={'app'}>\n            <div className={'container'}>\n                <Viewer/>\n            </div>\n            <a id=\"link\" rel=\"ar\" href=\"\" download=\"asset.usdz\">\n                <img id=\"button\" width=\"100\" src=\"files/arkit.png\"></img>\n            </a>\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import {Vector3} from \"three\";\nimport {Coordinate} from \"jsts/org/locationtech/jts/geom\";\n\nexport class ClayPoint {\n    origin;\n    direction;\n    position;\n\n    constructor(origin, direction) {\n        this.origin = origin;\n        this.position = new Vector3().copy(origin);\n        this.direction = direction;\n    }\n\n    move(value) {\n        this.position = new Vector3().addVectors(\n            this.position,\n            new Vector3().addScaledVector(this.direction, value)\n        );\n    }\n\n    set(value) {\n        this.position = new Vector3().addVectors(\n            this.origin,\n            new Vector3().addScaledVector(this.direction, value)\n        );\n    }\n\n    toCoordinate() {\n        return new Coordinate(\n            this.position.x,\n            this.position.y,\n            this.position.z\n        )\n    }\n\n    toVector3() {\n        return new Vector3().copy(this.position);\n    }\n}\n\nexport function clayPointTest() {\n    const vBase = new Vector3(0, 0, 0);\n    const vDir = new Vector3(1, 0, 0);\n\n    const clayPoint = new ClayPoint(vBase, vDir);\n\n    clayPoint.move(1.);\n\n    clayPoint.set(10.);\n}\n"],"sourceRoot":""}