{"version":3,"sources":["geometry/to-three.js","geometry/shaders-materials.js","geometry/importing-jsts.js","geometry/clayBrick/clay-point.js","geometry/clayBrick/clay-pattern-curve.js","geometry/jsts2Three/polyline.js","geometry/jsts2Three/jsts-to-three.js","geometry/test-geo.js","three-setup/renderers.js","three-setup/render-loops.js","three-setup/set-up.js","three-setup/cameras.js","three-setup/orbit-controls.js","Viewer.js","App.js","reportWebVitals.js","index.js"],"names":["TubeGeo","path","segs","radius","radSegs","closed","material","geo","TubeGeometry","Mesh","shaders","vertexShader","fragmentShader","transparent","uniforms","extensions","derivatives","triangulationFromPolygon","polygon","builder","DelaunayTriangulationBuilder","setSites","setTolerance","triangulation","getTriangles","GeometryFactory","console","log","edgesFromTriangulation","vertexDict","vPairs","pureVertices","boundary","_geometries","coords","getGeometryN","getCoordinates","length","cMap","idx","coor","coordinate","JSON","stringify","x","y","z","dictCount","Object","keys","Vector3","a","b","v0","Math","min","v1","max","idxVertex","v","lines","localLineCurve","LineCurve","push","bufferFromTriangulation","bufferGeo","BufferGeometry","coordinatesList","vertices","Float32Array","setAttribute","BufferAttribute","computeVertexNormals","multiplePoints","reader","WKTReader","geos","aString","pt","read","buffer","BufferOp","bufferOp","collection","createGeometryCollection","union","geometriesUnion","UnaryUnionOp","edges","displayPointTest","ClayPoint","origin","direction","this","position","copy","value","addVectors","addScaledVector","Coordinate","ClayPatternCurve","clayPoints","coordinates","toCoordinate","createPolygon","Polyline","points","dirs","getDirs","arcLengthDivisions","getPointCount","dirList","i","vDir","subVectors","lengths","getLengths","cacheArcLengths","needsUpdate","previous","u","optionalTarget","getTangent","t","vT","locT","roundT","isNaN","normalize","set","segments","normal","tangents","normals","binormals","vec","mat","Matrix4","getTangentAt","Number","MAX_VALUE","tx","abs","ty","tz","crossVectors","clone","EPSILON","theta","acos","clamp","dot","applyMatrix4","makeRotationAxis","t0","_tConstraining","Curve","createLinearRing","vectorFromCoordinate","locZ","linearRingToPolyline","linearRing","vectors","pop","polygonToPolylines","lrs","linearRings","getExteriorRing","getNumInteriorRing","getInteriorRingN","getLinearRings","polylines","lr","CustomSinCurve","scale","sin","PI","multiplyScalar","shaderMaterialEdges","ShaderMaterial","geoTubeTest","pls","testPolygon","blWhiteShader","tubes","pl","addTestGeos","scene","add","testTube","vBase","clayPoint","move","clayPointTest","pts","clayCurve","toPolygon","testClayCurve","tube","mesh","line","locTubeGeo","testJSTSTriangulation","resize","mount","renderer","camera","current","clientWidth","clientHeight","aspect","updateProjectionMatrix","setSize","start","frameId","requestAnimationFrame","animate","clear","render","setUp","Scene","WebGL1Renderer","antialias","alpha","setClearColor","setPixelRatio","window","devicePixelRatio","getPerspectiveRenderer","appendChild","domElement","PerspectiveCamera","getPerspectiveCamera","orbitControls","OrbitControls","enableRotate","enableKeys","target","update","getOrbitControls","cleanUp","cancelAnimationFrame","stop","removeChild","Viewer","useRef","rendererRef","cameraRef","useEffect","bounds","onResize","measureRef","className","ref","tabIndex","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.d8076200.chunk.js","sourcesContent":["import {Vector3, Curve, Mesh, TubeGeometry} from \"three\";\n\nexport function TubeGeo(path, segs, radius, radSegs, closed, material) {\n    const geo = new TubeGeometry(path, segs, radius, radSegs, closed);\n    return new Mesh(geo, material);\n}\n","export const shaders = {\n    normalShader: {\n        vertexShader: `\n            varying vec3 v_Normal;\n            void main() {\n                v_Normal = normal;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            varying vec3 v_Normal;\n            void main() {\n                gl_FragColor = vec4(v_Normal * .8, .8);\n                // vec3 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);\n    \n            }`,\n        transparent: true,\n        uniforms: {}\n    },\n\n    gridNormal: {\n        vertexShader: `\n            varying vec3 v_Position;\n            varying vec3 v_Normal;\n            void main() {\n                v_Position = position;\n                v_Normal = normal;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            varying vec3 v_Position;\n            varying vec3 v_Normal;\n            void main() {\n                vec3 grid = abs(fract(v_Position - 0.5) - 0.5) / fwidth(v_Position);\n                float line = min(min(grid.x, grid.y), grid.z);\n                float value = 3.- min(line,3.);\n                float transparency = .1 + value * .9;\n            \n                gl_FragColor = vec4(v_Normal * value, transparency);\n                // vec3 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);\n            }`,\n        transparent: true,\n        uniforms: {},\n        extensions: {derivatives: true}\n    },\n\n    grid: {\n        vertexShader: `\n            varying vec3 v_Position;\n            void main() {\n                v_Position = position;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            varying vec3 v_Position;\n            void main() {\n                vec3 grid = abs(fract(v_Position - .5) - .5) / fwidth(v_Position);\n                float line = min(min(grid.x, grid.y), grid.z);\n                float value = 2.5- min(line, 2.5);\n                float transparency = .1 + value * .9;\n\n                gl_FragColor = vec4(vec3(0.), transparency);\n                // vec3 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);\n            }`,\n        transparent: true,\n        uniforms: {},\n        extensions: {derivatives: true}\n    },\n\n    zGrid: {\n        vertexShader: `\n            varying float z_Position;\n            varying vec3 v_Normal;\n            void main() {\n                z_Position = position.z;\n                v_Normal = normal;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            varying float z_Position;\n            varying vec3 v_Normal;\n            void main() {\n                float line = abs(fract(z_Position - 0.5) - 0.5) / fwidth(z_Position);\n                float value = 3.- min(line,3.);\n                float transparency = .1 + value * .9;\n    \n                gl_FragColor = vec4(v_Normal * value, transparency);\n                // vec3 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);\n            }`,\n        transparent: true,\n        uniforms: {},\n        extensions: {derivatives: true}\n    },\n\n    edges: {\n        vertexShader: `\n            attribute vec2 barycentric;\n            varying vec2 b;\n            void main () {\n                b = barycentric;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }`,\n        fragmentShader: `\n            // float gridFactor (vec2 vBC, float width, float feather) {\n            //     float w1 = width - feather * 0.5;\n            //     vec3 bary = vec3(vBC.x, vBC.y, 1.0 - vBC.x - vBC.y);\n            //     vec3 d = fwidth(bary);\n            //     vec3 a3 = smoothstep(d * w1, d * (w1 + feather), bary);\n            //    \n            //     return min(min(a3.x, a3.y), a3.z);\n            // }\n            \n            float gridFactor (vec2 vBC, float width) {\n                vec3 bary = vec3(vBC.x, vBC.y, 1.0 - vBC.x - vBC.y);\n                vec3 d = fwidth(bary);\n                vec3 a3 = smoothstep(d * (width - 0.5), d * (width + 0.5), bary);\n                \n                return min(min(a3.x, a3.y), a3.z);\n            }\n            \n            varying vec2 b;\n            \n            void main () {\n                gl_FragColor = vec4(vec3(gridFactor(b, 1.0) * .6), 1);\n            }`,\n        transparent: true,\n        extensions: {derivatives: true}\n    }\n}\n","import {DelaunayTriangulationBuilder} from \"jsts/org/locationtech/jts/triangulate\";\nimport {WKTReader} from \"jsts/org/locationtech/jts/io\";\nimport BufferOp from \"jsts/org/locationtech/jts/operation/buffer/BufferOp\";\nimport {Geometry, GeometryCollection, GeometryFactory} from \"jsts/org/locationtech/jts/geom\";\nimport \"jsts/org/locationtech/jts/monkey.js\";\nimport {BufferAttribute, BufferGeometry, LineCurve, Vector3} from \"three\";\nimport {CustomLine} from \"./test-geo\";\nimport {UnaryUnionOp} from \"jsts/org/locationtech/jts/operation/union\";\n\nfunction triangulationFromPolygon(polygon) {\n    const builder = new DelaunayTriangulationBuilder();\n\n    builder.setSites(polygon);\n    builder.setTolerance(.01);\n\n    let triangulation = builder.getTriangles(new GeometryFactory());\n\n    console.log(triangulation);\n\n    return triangulation;\n}\n\nfunction polygonToBufferGeometry(polygon) {\n    const triangulation = triangulationFromPolygon(polygon);\n    return bufferFromTriangulation(triangulation);\n}\n\nfunction edgesFromTriangulation(triangulation) {\n    let vertexDict = {};\n    let vPairs = {};\n    let pureVertices = {};\n\n    for (const boundary in triangulation._geometries) {\n        const bnd = triangulation.getGeometryN(boundary);\n        const coords = bnd.getCoordinates();\n\n        if (coords.length === 4) {\n            let cMap = [0, 0, 0];\n            for (const idx in [0,1,2]) {\n                const coor = coords[idx];\n\n                let coordinate = JSON.stringify({x: coor.x, y: coor.y, z: .1});\n\n                const dictCount = Object.keys(vertexDict).length;\n\n                if (!(coordinate in vertexDict)) {\n                    // console.log(coordinate);\n\n                    vertexDict[coordinate] = dictCount;\n                    pureVertices[coordinate] = new Vector3(coor.x, coor.y, .1);\n                    cMap[idx] = dictCount;\n                } else {\n                    cMap[idx] = vertexDict[coordinate];\n                }\n            }\n\n            // console.log(cMap);\n\n            for (const idx in [0,1,2]) {\n                let a = cMap[idx];\n                let b = cMap[(idx + 1) % 3];\n\n                let v0 = Math.min(a, b);\n                let v1 = Math.max(a, b);\n\n                vPairs[JSON.stringify([v0, v1])] = [v0, v1];\n            }\n        }\n    }\n\n    let idxVertex = {};\n    for(const v in vertexDict){\n        const idx = vertexDict[v];\n        idxVertex[idx] = pureVertices[v];\n    }\n\n    let lines = [];\n\n    for (const idx in vPairs) {\n        // console.log(vPairs[idx]);\n\n        const a = vPairs[idx][0];\n        const b = vPairs[idx][1];\n\n        // console.log(vPairs);\n        // console.log(a, b);\n        // console.log(idxVertex[a], idxVertex[b]);\n\n        const localLineCurve = new LineCurve(idxVertex[a], idxVertex[b]);\n\n        // localLineCurve.arcLengthDivisions = 1;\n\n        lines.push(localLineCurve);\n    }\n\n    return lines;\n}\n\nfunction bufferFromTriangulation(triangulation) {\n    // let geoCollection = new GeometryCollection();\n\n    let bufferGeo = new BufferGeometry();\n    let coordinatesList = [];\n\n    for (const boundary in triangulation._geometries) {\n        const bnd = triangulation.getGeometryN(boundary);\n        const coords = bnd.getCoordinates();\n\n        if (coords.length === 4) {\n            for (const idx in [0,1,2]) {\n                const coor = coords[idx];\n                coordinatesList.push(coor.x);\n                coordinatesList.push(coor.y);\n                coordinatesList.push(.1);\n            }\n        }\n    }\n\n    const vertices = new Float32Array( coordinatesList );\n\n    bufferGeo.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n    bufferGeo.computeVertexNormals();\n\n    return bufferGeo;\n}\n\nexport function displayPoint(aString) {\n    let reader = new WKTReader();\n\n    let pt = reader.read(aString);\n\n    let buffered = BufferOp.bufferOp(pt, 20);\n\n    const triangulation = triangulationFromPolygon(buffered);\n\n    return {\n        buffer: bufferFromTriangulation(triangulation),\n        edges: edgesFromTriangulation(triangulation)\n    };\n}\n\nexport function geometriesUnion(geos) {\n    if (geos.length === 1){\n        return geos[0];\n    }\n\n    const geoFac = new GeometryFactory();\n    const geoCollection = geoFac.createGeometryCollection(geos).union();\n\n    return geoCollection;\n}\n\nexport function multiplePoints(){\n    let reader = new WKTReader();\n\n    const strings = [\n        'POINT (-20 0)',\n        'POINT (20 0)',\n        'POINT (0 15)'\n    ];\n\n    let geos = [];\n\n    for (const aString of strings) {\n        const pt = reader.read(aString);\n        const buffer = BufferOp.bufferOp(pt, 30)\n\n        geos.push(buffer);\n    }\n\n    const collection = geometriesUnion(geos);\n\n    let geom = UnaryUnionOp.union(collection);\n\n    const triangulation = triangulationFromPolygon(geom);\n\n    return {\n        buffer: bufferFromTriangulation(triangulation),\n        edges: edgesFromTriangulation(triangulation)\n    };\n}\n\nexport function testPolygon() {\n    let reader = new WKTReader();\n\n    const pt = reader.read('POINT (0 0)');\n    const buffer = BufferOp.bufferOp(pt, 30)\n\n    return buffer;\n}\n\nexport function displayPointTest(){\n    return multiplePoints();\n}\n","import {Vector3} from \"three\";\nimport {Coordinate} from \"jsts/org/locationtech/jts/geom\";\n\nexport class ClayPoint {\n    origin;\n    direction;\n    position;\n\n    constructor(origin, direction) {\n        this.origin = origin;\n        this.position = new Vector3().copy(origin);\n        this.direction = direction;\n    }\n\n    move(value) {\n        this.position = new Vector3().addVectors(\n            this.position,\n            new Vector3().addScaledVector(this.direction, value)\n        );\n    }\n\n    set(value) {\n        this.position = new Vector3().addVectors(\n            this.origin,\n            new Vector3().addScaledVector(this.direction, value)\n        );\n    }\n\n    toCoordinate(value) {\n        return new Coordinate(\n            this.position.x,\n            this.position.y,\n            this.position.z\n        )\n    }\n}\n\nexport function clayPointTest() {\n    const vBase = new Vector3(0, 0, 0);\n    const vDir = new Vector3(1, 0, 0);\n\n    const clayPoint = new ClayPoint(vBase, vDir);\n\n    clayPoint.move(1.);\n\n    clayPoint.set(10.);\n}\n","import {GeometryFactory} from \"jsts/org/locationtech/jts/geom\";\nimport {ClayPoint} from './clay-point';\nimport {Vector3} from \"three\";\n\nclass ClayPatternCurve {\n    clayPoints;\n\n    constructor(clayPoints) {\n        this.clayPoints = clayPoints;\n    }\n\n    toPolygon() {\n        let coordinates =[];\n\n        // const crds = new Coordinates();\n        //\n        // crds.\n\n        for (const pt of this.clayPoints) {\n            coordinates.push(pt.toCoordinate());\n        }\n\n        coordinates.push(coordinates[0]);\n\n        return new GeometryFactory().createPolygon(coordinates)\n\n        // const lr = new LinearRing(coordinates);\n        // return new Polygon(lr);\n    }\n}\n\nexport function testClayCurve(scene = null) {\n    let pts = [\n        new ClayPoint(\n            new Vector3(.5, .5, 0),\n            new Vector3(1, 1, 0),\n        ),\n        new ClayPoint(\n            new Vector3(-.5, .5, 0),\n            new Vector3(-1, 1, 0),\n        ),\n        new ClayPoint(\n            new Vector3(-.5, -.5, 0),\n            new Vector3(-1, -1, 0),\n        ),\n        new ClayPoint(\n            new Vector3(.5, -.5, 0),\n            new Vector3(1, -1, 0),\n        ),\n    ];\n\n    const clayCurve = new ClayPatternCurve(pts);\n    console.log(clayCurve);\n\n    console.log(clayCurve.toPolygon());\n\n    console.log(scene);\n\n    if (scene) {\n        // console.log(\"is not null?\");\n        // console.log(scene);\n\n\n\n    } else {\n        console.log(\"is null !!!\");\n    }\n}\n","import {Curve, Matrix4, Vector3} from 'three';\nimport {clamp} from \"three/src/math/MathUtils\";\n\nexport class Polyline extends Curve {\n    constructor(points, closed = true) {\n        super();\n\n        this.points = points;\n        this.closed = closed;\n\n        this.dirs = this.getDirs();\n\n        this.arcLengthDivisions = this.getPointCount();\n    }\n\n    getPointCount() {\n        if (this.closed) {\n            return this.points.length;\n        } else {\n            return this.points.length - 1;\n        }\n    }\n\n    getDirs() {\n        let dirList = [];\n\n        for (let i = 0; i < this.getPointCount(); i++) {\n            const v0 = this.points[i];\n            const v1 = this.points[(i+1) % this.getPointCount()];\n\n            const vDir = new Vector3().subVectors(v1, v0);\n\n            dirList.push(vDir);\n        }\n\n        return dirList;\n    }\n\n    getLength() {\n        const lengths = this.getLengths();\n        return lengths[lengths.length - 1];\n    }\n\n    getLengths() {\n        if ( this.cacheArcLengths &&\n            ( this.cacheArcLengths.length === this.getPointCount() + 1 ) &&\n            ! this.needsUpdate ) {\n\n            return this.cacheArcLengths;\n        }\n\n        let previous = 0.;\n        this.cacheArcLengths = [previous];\n\n        for (const dir of this.dirs) {\n            previous += dir.length();\n            this.cacheArcLengths.push(previous);\n        }\n\n        return this.cacheArcLengths;\n    }\n\n    getTangentAt(u, optionalTarget = new Vector3()) {\n        return this.getTangent(u * this.getPointCount(), optionalTarget)\n    }\n\n    getTangent(t, optionalTarget = new Vector3()) {\n        const locT = t % 1.;\n        let roundT = t - t % 1.;\n\n        if (isNaN(t)) {\n            return null;\n        }\n\n        let vT;\n\n        if (t > 0 && t < this.getPointCount()) {\n            if ( locT < .0001 ) {\n                const v1 = new Vector3().copy(this.dirs[roundT]);\n                const v0 = new Vector3().copy(this.dirs[roundT - 1]);\n\n                v0.normalize();\n                v1.normalize();\n\n                vT = new Vector3().addVectors(v0, v1);\n            } else {\n                vT = new Vector3().copy(this.dirs[roundT]);\n            }\n        }\n\n        if (this.closed) {\n            roundT %= this.getPointCount();\n\n            if ( locT < .0001 ) {\n                const v1 = new Vector3().copy(this.dirs[roundT]);\n                const v0 = new Vector3().copy(this.dirs[(roundT + this.getPointCount() - 1) % this.getPointCount()]);\n\n                v0.normalize();\n                v1.normalize();\n\n                vT = new Vector3().addVectors(v0, v1);\n            } else {\n                vT = new Vector3().copy(this.dirs[roundT]);\n            }\n        } else {\n            if (t < 1) {\n                vT = new Vector3().copy(this.dirs[0]);\n            } else {\n                vT = new Vector3().copy(this.dirs[this.dirs.length - 1]);\n            }\n        }\n\n        vT.normalize();\n        return optionalTarget.set(vT.x, vT.y, vT.z);\n    }\n\n    computeFrenetFrames( segments, closed ) {\n\n        // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n        const normal = new Vector3();\n\n        const tangents = [];\n        const normals = [];\n        const binormals = [];\n\n        const vec = new Vector3();\n        const mat = new Matrix4();\n\n        // compute the tangent vectors for each segment on the curve\n\n        for ( let i = 0; i <= segments; i ++ ) {\n\n            const u = i / segments;\n\n            tangents[ i ] = this.getTangentAt( u, new Vector3() );\n\n        }\n\n        // select an initial normal vector perpendicular to the first tangent vector,\n        // and in the direction of the minimum tangent xyz component\n\n        normals[ 0 ] = new Vector3();\n        binormals[ 0 ] = new Vector3();\n        let min = Number.MAX_VALUE;\n        const tx = Math.abs( tangents[ 0 ].x );\n        const ty = Math.abs( tangents[ 0 ].y );\n        const tz = Math.abs( tangents[ 0 ].z );\n\n        if ( tx <= min ) {\n\n            min = tx;\n            normal.set( 1, 0, 0 );\n\n        }\n\n        if ( ty <= min ) {\n\n            min = ty;\n            normal.set( 0, 1, 0 );\n\n        }\n\n        if ( tz <= min ) {\n\n            normal.set( 0, 0, 1 );\n\n        }\n\n        vec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n        normals[ 0 ].crossVectors( tangents[ 0 ], vec );\n        binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n        // compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n        for ( let i = 1; i <= segments; i ++ ) {\n\n            normals[ i ] = normals[ i - 1 ].clone();\n\n            binormals[ i ] = binormals[ i - 1 ].clone();\n\n            vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n            if ( vec.length() > Number.EPSILON ) {\n\n                vec.normalize();\n\n                const theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n                normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n            }\n\n            binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n        }\n\n        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n        if ( closed === true ) {\n\n            let theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n            theta /= segments;\n\n            if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n                theta = - theta;\n\n            }\n\n            for ( let i = 1; i <= segments; i ++ ) {\n\n                // twist a little...\n                normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n                binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n            }\n\n        }\n\n        console.log({\n            tangents: tangents,\n            normals: normals,\n            binormals: binormals\n        });\n\n        return {\n            tangents: tangents,\n            normals: normals,\n            binormals: binormals\n        };\n\n    }\n\n    _tConstraining(t) {\n        let locT = t % 1.;\n\n        let t0 = t - locT;\n\n        if (this.closed) {\n            t0 %= this.getPointCount();\n        } else {\n            if (t0 < 0) {\n                locT += t0;\n                t0 = 0;\n            } else if (t0 >= this.getPointCount()) {\n                locT += t0 - this.getPointCount();\n                t0 = this.getPointCount();\n            }\n        }\n\n        return {\n            locT: locT,\n            t0: t0\n        };\n    }\n\n    getPoint( t, optionalTarget = new Vector3() ) {\n        t *= this.getPointCount();\n\n        // console.log(t);\n\n        const {locT, t0} = this._tConstraining(t);\n\n        // console.log(locT, t0);\n\n        const v0 = this.points[t0];\n        const vDir = this.dirs[t0];\n\n        const v = new Vector3().addVectors(v0, new Vector3().addScaledVector(locT, vDir));\n\n        return optionalTarget.set(v.x, v.y, v.z);\n\n        //just checking\n    }\n}\n","import {GeometryFactory} from \"jsts/org/locationtech/jts/geom\";\nimport {Path, Vector3} from \"three\";\nimport {Polyline} from \"./polyline\";\nimport {testPolygon} from \"../importing-jsts\";\n\nconst llr = new GeometryFactory().createLinearRing();\n\nfunction getLinearRings(polygon) {\n    let linearRings = [];\n    linearRings.push(polygon.getExteriorRing());\n\n    console.log(polygon);\n\n    for (let i = 0; i < polygon.getNumInteriorRing(); i++) {\n        linearRings.push(polygon.getInteriorRingN(i));\n    }\n\n    return linearRings;\n}\n\nfunction vectorFromCoordinate(coordinate) {\n    let locZ;\n\n    if (isNaN(coordinate.z)) {\n        locZ = 0;\n    } else {\n        locZ = coordinate.z;\n    }\n\n    return new Vector3(\n        coordinate.x,\n        coordinate.y,\n        locZ\n    );\n}\n\nfunction linearRingToPolyline(linearRing) {\n    let vectors = [];\n\n    for (const coordinate of linearRing.getCoordinates()) {\n        vectors.push(vectorFromCoordinate(coordinate) );\n    }\n\n    vectors.pop();\n\n    return new Polyline(vectors);\n}\n\nexport function polygonToPolylines(polygon){\n    const lrs = getLinearRings(polygon);\n\n    let polylines = [];\n    for (const lr of lrs){\n        polylines.push(linearRingToPolyline(lr));\n    }\n\n    console.log(polylines);\n\n    return polylines;\n}\n","import {\n    Curve,\n    // EdgesGeometry,\n    // CurveLine,\n    // LineBasicMaterial,\n    // LineSegments,\n    Matrix4,\n    Mesh,\n    ShaderMaterial,\n    // Vector2,\n    Vector3\n} from \"three\";\nimport {TubeGeo} from \"./to-three\";\nimport {shaders} from \"./shaders-materials\";\nimport {displayPointTest, testPolygon} from \"./importing-jsts\";\nimport {clayPointTest} from \"./clayBrick/clay-point\";\nimport {testClayCurve} from \"./clayBrick/clay-pattern-curve\";\nimport {polygonToPolylines} from \"./jsts2Three/jsts-to-three\";\n\nclass CustomSinCurve extends Curve {\n\n    constructor( scale = 1 ) {\n\n        super();\n\n        this.scale = scale;\n\n    }\n\n    getPoint( t, optionalTarget = new Vector3() ) {\n\n        const tx = t * 3 - 1.5;\n        const ty = Math.sin( 2 * Math.PI * t );\n        const tz = 0;\n\n        return optionalTarget.set( tx, ty, tz ).multiplyScalar( this.scale );\n    }\n}\n\nexport class CustomLine extends Curve {\n\n    constructor(v0, v1) {\n        super();\n\n        this.v0 = v0;\n        this.vDir = v1 - this.v0;\n\n        this.scale = 1.;\n    }\n\n    getPoint(t, optionalTarget = new Vector3()) {\n        const v = this.v0 + t * this.vDir;\n        // console.log(v);\n\n        return optionalTarget.set(v.x, v.y, v.z).multiplyScalar( this.scale );\n    }\n}\n\nfunction shaderMaterialEdges() {\n    return new ShaderMaterial( shaders.grid );\n}\n\nexport function shaderNormal() {\n    return new ShaderMaterial(shaders.normalShader);\n}\n\nexport function testTube() {\n    // const material = new MeshBasicMaterial( { color: 0xff2211 } );\n    const material = shaderMaterialEdges();\n    const path = new CustomSinCurve( 10 );\n\n    return TubeGeo(path, 100, 2., 32, false, material);\n}\n\nexport function testJSTSTriangulation(scene) {\n    const {buffer, edges} = displayPointTest();\n    const material = shaderMaterialEdges();\n\n    const mesh = new Mesh(buffer, material);\n\n    // const lines = new LineSegments(\n    //     new EdgesGeometry(bufferGeo, 0),\n    //     new LineBasicMaterial({color:'black', linewidth: 3.})\n    // );\n\n    // mesh.add(edges);\n\n    scene.add(mesh);\n\n    const blWhiteShader = new ShaderMaterial(shaders.normalShader);\n\n    for (const line in edges) {\n        const aLine = edges[line];\n\n        // console.log(aLine);\n\n        const locTubeGeo = TubeGeo(aLine, 32, .5, 32, false, blWhiteShader);\n\n        // console.log(locTubeGeo);\n        scene.add(locTubeGeo);\n    }\n\n\n    // scene.add(locTubeGeo);\n}\n//\n// export function getLinesFromMesh(mesh) {\n//     return new LineSegments(\n//         new EdgesGeometry(mesh.geometry),\n//         new LineBasicMaterial()\n//     );\n// }\nexport function geoTubeTest() {\n    const polygon = testPolygon();\n    const pls = polygonToPolylines(polygon);\n\n    const blWhiteShader = new ShaderMaterial(shaders.normalShader);\n\n    let tubes = [];\n    for (const pl of pls) {\n        tubes.push(TubeGeo(pl, 32, .5, 32, false, blWhiteShader))\n    }\n\n    return tubes;\n}\n\n\nexport function addTestGeos(scene) {\n    scene.add(testTube());\n\n    clayPointTest();\n    testClayCurve(scene);\n\n    for (const tube of geoTubeTest()) {\n        scene.add(tube);\n    }\n\n    testJSTSTriangulation(scene);\n}\n","import {WebGL1Renderer, WebGLRenderer} from 'three'\n\nexport function getPlanarRenderer() {\n    const renderer = new WebGLRenderer({antialias: true});\n\n    renderer.setClearColor('#cdd0d6');\n    renderer.setPixelRatio(window.devicePixelRatio);\n\n    return renderer;\n}\n\nexport function getPerspectiveRenderer() {\n    const renderer = new WebGL1Renderer({antialias: true, alpha: true})\n\n    renderer.setClearColor('#ffff99');\n    renderer.setPixelRatio(window.devicePixelRatio);\n\n    return renderer;\n}\n\nexport function resize(mount, renderer, camera) {\n    if (!mount || !renderer || !camera)\n        return\n\n    const {clientWidth, clientHeight} = mount.current\n\n    if (camera) {\n        camera.aspect = clientWidth / clientHeight;\n        camera.updateProjectionMatrix();\n    }\n\n    renderer.setSize(clientWidth, clientHeight)\n}\n","export function start(renderer, scene, camera) {\n\n    const frameId = {frameId: null};\n\n    frameId.frameId = requestAnimationFrame(() => animate(renderer, scene, camera, frameId));\n\n    return frameId;\n}\n\nexport function stop({frameId}) {\n    return cancelAnimationFrame(frameId);\n}\n\nfunction animate(renderer, scene, camera, frameId) {\n    renderer.clear('#ddd');\n    renderer.render(scene, camera);\n\n    frameId.frameId = requestAnimationFrame(() => animate(renderer, scene, camera, frameId));\n}\n","import {Scene} from 'three';\nimport {getPerspectiveRenderer, resize} from \"./renderers\";\nimport {getOrbitControls} from \"./orbit-controls\";\nimport {getPerspectiveCamera} from \"./cameras\";\nimport {start, stop} from \"./render-loops\";\nimport {addTestGeos, testTube} from \"../geometry/test-geo\";\nimport {displayPointTest} from \"../geometry/importing-jsts\";\n\nexport function setUp(mount) {\n    const scene = new Scene();\n\n    addTestGeos(scene);\n\n    displayPointTest();\n\n    const renderer = getPerspectiveRenderer();\n    mount.current.appendChild(renderer.domElement);\n\n    const camera = getPerspectiveCamera(mount.current);\n    scene.add(camera);\n\n    const orbitControls = getOrbitControls(camera, renderer);\n\n    resize(mount, renderer, camera);\n    const frameId = start(renderer, scene, camera);\n\n    return {\n        scene: scene,\n        renderer: renderer,\n        camera: camera,\n        frameId: frameId,\n        orbitControls: orbitControls\n    };\n}\n\nexport function cleanUp(mount, renderer, frameId) {\n    stop(frameId.frameId);\n    mount.current.removeChild(renderer.domElement);\n}\n","import {OrthographicCamera, PerspectiveCamera} from 'three'\n\nexport function getOrthographicCamera(mount) {\n    const {clientWidth, clientHeight} = mount;\n\n    const camera = new OrthographicCamera(\n        clientWidth / -16,\n        clientWidth /16,\n        clientHeight / 16,\n        clientHeight / -16,\n        -1,\n        100\n    );\n\n    camera.enableRotate = false;\n    camera.position.z = 20;\n\n    return camera;\n}\n\nexport function getPerspectiveCamera(mount) {\n    const {clientWidth, clientHeight} = mount;\n\n    const camera = new PerspectiveCamera(\n        45,\n        clientWidth / clientHeight\n    );\n\n    camera.position.z = 20;\n    return camera;\n}\n","import {MOUSE} from 'three';\nimport {OrbitControls} from \"three/examples/jsm/controls/OrbitControls\";\n\nexport function getOrbitControls(camera, renderer) {\n    const orbitControls = new OrbitControls(camera, renderer.domElement);\n    orbitControls.enableRotate = true;\n    orbitControls.enableKeys = true;\n    // orbitControls.minZoom = .5;\n    // orbitControls.maxZoom = 8;\n    // orbitControls.mouseButtons = {ZOOM: MOUSE.MIDDLE, PAN: MOUSE.RIGHT};\n\n    orbitControls.target.set(0, 0);\n    orbitControls.update();\n\n    return orbitControls;\n}\n\n","import React, {useEffect, useRef} from 'react';\nimport Measure from 'react-measure';\nimport {cleanUp, setUp} from \"./three-setup/set-up\";\nimport {resize} from \"./three-setup/renderers\";\n\nimport './Viewer.scss';\n\nfunction Viewer() {\n    const mount = useRef(null);\n    const rendererRef = useRef(null);\n    const cameraRef = useRef(null);\n\n    useEffect(() => {\n        console.log(mount);\n\n        const {scene, camera, renderer, frameId} = setUp(mount);\n\n        rendererRef.current = renderer;\n        cameraRef.current = camera;\n\n        return () => {\n            cleanUp(mount, renderer, frameId);\n        }\n    }, [rendererRef, cameraRef]);\n\n    return (\n        <Measure\n            bounds\n            onResize={() => {\n                resize(mount, rendererRef.current, cameraRef.current)\n            }}>\n            {({measureRef}) => (\n                <div className={'simple-3d'} ref={measureRef}>\n                    <div className={'three-canvas'} ref={mount} tabIndex={0}/>\n                </div>\n            )}\n        </Measure>\n    )\n}\n\nexport default Viewer;\n","// ... App.js\nimport React, {Component} from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as THREE from \"three\";\nimport {TestGeo} from \"./geometry/test-geo\";\nimport {setUp} from \"./three-setup/set-up\";\n\nimport './App.css';\nimport Viewer from \"./Viewer\";\n\nfunction App() {\n    return (\n        <div className={'app'}>\n            <div className={'container'}>\n                <Viewer/>\n            </div>\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}